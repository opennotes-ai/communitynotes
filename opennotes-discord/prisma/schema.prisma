// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(cuid())
  discordId         String   @unique
  username          String
  discriminator     String?
  avatar            String?
  helpfulnessScore  Float    @default(0.0)
  totalNotes        Int      @default(0)
  totalRatings      Int      @default(0)
  joinedAt          DateTime @default(now())
  lastActiveAt      DateTime @default(now())

  // Rate limiting fields
  dailyRequestCount Int      @default(0)
  lastRequestDate   DateTime?

  // Trust and reputation fields
  verifiedAt        DateTime?
  trustLevel        String   @default("newcomer") // newcomer, contributor, trusted

  // Notification preferences
  notifyNewRequests       Boolean @default(true)
  notifyNotePublished     Boolean @default(true)
  notifyNoteRatings       Boolean @default(true)
  notifyStatusChanged     Boolean @default(true)
  notifyMilestones        Boolean @default(true)
  notificationBatching    Boolean @default(true)
  batchingInterval        Int     @default(30) // minutes
  notificationMethods     String[] @default(["discord_dm"]) // discord_dm, channel_mention
  notificationsMutedUntil DateTime?

  // Relations
  noteRequests      NoteRequest[]
  communityNotes    OpenNote[]
  noteRatings       NoteRating[]
  serverMemberships ServerMember[]

  @@map("users")
}

model Server {
  id               String   @id @default(cuid())
  discordId        String   @unique
  name             String
  icon             String?
  enabled          Boolean  @default(true)
  joinedAt         DateTime @default(now())

  // Configuration
  allowNoteRequests    Boolean @default(true)
  allowNoteCreation    Boolean @default(true)
  maxRequestsPerUser   Int     @default(5)
  requireVerification  Boolean @default(true)

  // Channel configuration
  enabledChannels  String[] @default([])
  disabledChannels String[] @default([])
  moderatorRoles   String[] @default([])
  contributorRoles String[] @default([])

  // Emergency controls
  isPaused         Boolean  @default(false)
  pausedAt         DateTime?
  pausedBy         String?
  pauseReason      String?

  // Relations
  messages         Message[]
  serverMembers    ServerMember[]
  auditLogs        AuditLog[]

  @@map("servers")
}

model ServerMember {
  id       String @id @default(cuid())
  userId   String
  serverId String
  roles    String[] @default([])
  joinedAt DateTime @default(now())

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  server Server @relation(fields: [serverId], references: [id], onDelete: Cascade)

  @@unique([userId, serverId])
  @@map("server_members")
}

model Message {
  id           String   @id @default(cuid())
  discordId    String   @unique
  channelId    String
  serverId     String
  authorId     String
  content      String
  attachments  String[] @default([])
  timestamp    DateTime
  createdAt    DateTime @default(now())

  // Aggregated stats
  totalRequests     Int @default(0)
  uniqueRequestors  Int @default(0)
  hasActiveNote     Boolean @default(false)

  // Relations
  server        Server        @relation(fields: [serverId], references: [id], onDelete: Cascade)
  noteRequests  NoteRequest[]
  communityNotes OpenNote[]

  @@index([serverId, channelId])
  @@index([timestamp])
  @@map("messages")
}

model NoteRequest {
  id          String   @id @default(cuid())
  messageId   String
  requestorId String
  reason      String?
  sources     String[] @default([])
  timestamp   DateTime @default(now())

  // Request metadata
  isActive    Boolean @default(true)

  // Relations
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  requestor User    @relation(fields: [requestorId], references: [id], onDelete: Cascade)

  @@unique([messageId, requestorId])
  @@index([messageId])
  @@index([requestorId])
  @@index([timestamp])
  @@map("note_requests")
}

model OpenNote {
  id             String   @id @default(cuid())
  messageId      String
  authorId       String
  content        String
  classification String   // misleading, lacking-context, disputed, unsubstantiated
  sources        String[] @default([])

  // Status and lifecycle
  status         String   @default("pending") // pending, crh, nrh, needs-more-ratings
  submittedAt    DateTime @default(now())
  lastStatusAt   DateTime @default(now())

  // Rating aggregation
  helpfulCount      Int @default(0)
  notHelpfulCount   Int @default(0)
  totalRatings      Int @default(0)
  helpfulnessRatio  Float @default(0.0)

  // Visibility
  isVisible         Boolean @default(false)
  visibilityScore   Float   @default(0.0)

  // Relations
  message     Message      @relation(fields: [messageId], references: [id], onDelete: Cascade)
  author      User         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  ratings     NoteRating[]

  @@index([messageId])
  @@index([authorId])
  @@index([status])
  @@index([isVisible])
  @@map("community_notes")
}

model NoteRating {
  id        String   @id @default(cuid())
  noteId    String
  raterId   String
  helpful   Boolean
  reason    String?
  timestamp DateTime @default(now())

  // Rating quality metrics
  weight    Float @default(1.0)

  // Relations
  note  OpenNote @relation(fields: [noteId], references: [id], onDelete: Cascade)
  rater User     @relation(fields: [raterId], references: [id], onDelete: Cascade)

  @@unique([noteId, raterId])
  @@index([noteId])
  @@index([raterId])
  @@map("note_ratings")
}

model RequestAggregation {
  id                String   @id @default(cuid())
  messageId         String   @unique
  totalRequests     Int      @default(0)
  uniqueRequestors  Int      @default(0)
  firstRequestAt    DateTime?
  lastRequestAt     DateTime?

  // Threshold tracking
  thresholdMet      Boolean  @default(false)
  thresholdMetAt    DateTime?

  // Contributors notified
  contributorsNotified Boolean @default(false)
  notifiedAt          DateTime?

  @@index([totalRequests])
  @@index([thresholdMet])
  @@map("request_aggregations")
}

model RateLimiting {
  id           String   @id @default(cuid())
  userId       String
  limitType    String   // daily_requests, note_creation, rating
  count        Int      @default(0)
  resetAt      DateTime
  createdAt    DateTime @default(now())

  @@unique([userId, limitType])
  @@index([userId])
  @@index([resetAt])
  @@map("rate_limiting")
}

model AuditLog {
  id        String   @id @default(cuid())
  serverId  String
  adminId   String
  action    String   // enable_channel, disable_channel, add_contributor, remove_contributor, pause, resume, bulk_delete, etc.
  target    String?  // channel_id, user_id, note_id, etc.
  details   Json?    // additional action details
  timestamp DateTime @default(now())

  // Relations
  server Server @relation(fields: [serverId], references: [id], onDelete: Cascade)

  @@index([serverId])
  @@index([action])
  @@index([timestamp])
  @@map("audit_logs")
}

model ModerationQueue {
  id          String   @id @default(cuid())
  serverId    String
  itemType    String   // note_request, community_note
  itemId      String
  flagType    String   // spam, abuse, inappropriate, misleading
  flaggedBy   String
  reason      String?
  status      String   @default("pending") // pending, reviewed, dismissed, actioned
  reviewedBy  String?
  reviewedAt  DateTime?
  actionTaken String?  // deleted, warned, no_action
  createdAt   DateTime @default(now())

  @@index([serverId])
  @@index([status])
  @@index([itemType])
  @@index([createdAt])
  @@map("moderation_queue")
}

model NotificationQueue {
  id           String   @id @default(cuid())
  userId       String
  type         String   // notification type enum value
  priority     Int      @default(2) // 1=low, 2=medium, 3=high, 4=urgent
  data         Json     // notification data payload
  status       String   @default("pending") // pending, sent, failed, batched
  attempts     Int      @default(0)
  maxAttempts  Int      @default(3)
  scheduledFor DateTime?
  createdAt    DateTime @default(now())
  lastAttemptAt DateTime?
  batchKey     String?  // for grouping notifications together
  batchedAt    DateTime?

  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([scheduledFor])
  @@index([batchKey])
  @@index([createdAt])
  @@map("notification_queue")
}