
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Server
 * 
 */
export type Server = $Result.DefaultSelection<Prisma.$ServerPayload>
/**
 * Model ServerMember
 * 
 */
export type ServerMember = $Result.DefaultSelection<Prisma.$ServerMemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model NoteRequest
 * 
 */
export type NoteRequest = $Result.DefaultSelection<Prisma.$NoteRequestPayload>
/**
 * Model OpenNote
 * 
 */
export type OpenNote = $Result.DefaultSelection<Prisma.$OpenNotePayload>
/**
 * Model NoteRating
 * 
 */
export type NoteRating = $Result.DefaultSelection<Prisma.$NoteRatingPayload>
/**
 * Model RequestAggregation
 * 
 */
export type RequestAggregation = $Result.DefaultSelection<Prisma.$RequestAggregationPayload>
/**
 * Model RateLimiting
 * 
 */
export type RateLimiting = $Result.DefaultSelection<Prisma.$RateLimitingPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ModerationQueue
 * 
 */
export type ModerationQueue = $Result.DefaultSelection<Prisma.$ModerationQueuePayload>
/**
 * Model NotificationQueue
 * 
 */
export type NotificationQueue = $Result.DefaultSelection<Prisma.$NotificationQueuePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.server`: Exposes CRUD operations for the **Server** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servers
    * const servers = await prisma.server.findMany()
    * ```
    */
  get server(): Prisma.ServerDelegate<ExtArgs>;

  /**
   * `prisma.serverMember`: Exposes CRUD operations for the **ServerMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServerMembers
    * const serverMembers = await prisma.serverMember.findMany()
    * ```
    */
  get serverMember(): Prisma.ServerMemberDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.noteRequest`: Exposes CRUD operations for the **NoteRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteRequests
    * const noteRequests = await prisma.noteRequest.findMany()
    * ```
    */
  get noteRequest(): Prisma.NoteRequestDelegate<ExtArgs>;

  /**
   * `prisma.openNote`: Exposes CRUD operations for the **OpenNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenNotes
    * const openNotes = await prisma.openNote.findMany()
    * ```
    */
  get openNote(): Prisma.OpenNoteDelegate<ExtArgs>;

  /**
   * `prisma.noteRating`: Exposes CRUD operations for the **NoteRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteRatings
    * const noteRatings = await prisma.noteRating.findMany()
    * ```
    */
  get noteRating(): Prisma.NoteRatingDelegate<ExtArgs>;

  /**
   * `prisma.requestAggregation`: Exposes CRUD operations for the **RequestAggregation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestAggregations
    * const requestAggregations = await prisma.requestAggregation.findMany()
    * ```
    */
  get requestAggregation(): Prisma.RequestAggregationDelegate<ExtArgs>;

  /**
   * `prisma.rateLimiting`: Exposes CRUD operations for the **RateLimiting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateLimitings
    * const rateLimitings = await prisma.rateLimiting.findMany()
    * ```
    */
  get rateLimiting(): Prisma.RateLimitingDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.moderationQueue`: Exposes CRUD operations for the **ModerationQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationQueues
    * const moderationQueues = await prisma.moderationQueue.findMany()
    * ```
    */
  get moderationQueue(): Prisma.ModerationQueueDelegate<ExtArgs>;

  /**
   * `prisma.notificationQueue`: Exposes CRUD operations for the **NotificationQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationQueues
    * const notificationQueues = await prisma.notificationQueue.findMany()
    * ```
    */
  get notificationQueue(): Prisma.NotificationQueueDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Server: 'Server',
    ServerMember: 'ServerMember',
    Message: 'Message',
    NoteRequest: 'NoteRequest',
    OpenNote: 'OpenNote',
    NoteRating: 'NoteRating',
    RequestAggregation: 'RequestAggregation',
    RateLimiting: 'RateLimiting',
    AuditLog: 'AuditLog',
    ModerationQueue: 'ModerationQueue',
    NotificationQueue: 'NotificationQueue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "server" | "serverMember" | "message" | "noteRequest" | "openNote" | "noteRating" | "requestAggregation" | "rateLimiting" | "auditLog" | "moderationQueue" | "notificationQueue"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Server: {
        payload: Prisma.$ServerPayload<ExtArgs>
        fields: Prisma.ServerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          findFirst: {
            args: Prisma.ServerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          findMany: {
            args: Prisma.ServerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>[]
          }
          create: {
            args: Prisma.ServerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          createMany: {
            args: Prisma.ServerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>[]
          }
          delete: {
            args: Prisma.ServerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          update: {
            args: Prisma.ServerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          deleteMany: {
            args: Prisma.ServerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          aggregate: {
            args: Prisma.ServerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServer>
          }
          groupBy: {
            args: Prisma.ServerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServerCountArgs<ExtArgs>
            result: $Utils.Optional<ServerCountAggregateOutputType> | number
          }
        }
      }
      ServerMember: {
        payload: Prisma.$ServerMemberPayload<ExtArgs>
        fields: Prisma.ServerMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServerMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServerMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>
          }
          findFirst: {
            args: Prisma.ServerMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServerMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>
          }
          findMany: {
            args: Prisma.ServerMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>[]
          }
          create: {
            args: Prisma.ServerMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>
          }
          createMany: {
            args: Prisma.ServerMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServerMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>[]
          }
          delete: {
            args: Prisma.ServerMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>
          }
          update: {
            args: Prisma.ServerMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>
          }
          deleteMany: {
            args: Prisma.ServerMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServerMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServerMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerMemberPayload>
          }
          aggregate: {
            args: Prisma.ServerMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServerMember>
          }
          groupBy: {
            args: Prisma.ServerMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServerMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServerMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ServerMemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      NoteRequest: {
        payload: Prisma.$NoteRequestPayload<ExtArgs>
        fields: Prisma.NoteRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>
          }
          findFirst: {
            args: Prisma.NoteRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>
          }
          findMany: {
            args: Prisma.NoteRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>[]
          }
          create: {
            args: Prisma.NoteRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>
          }
          createMany: {
            args: Prisma.NoteRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>[]
          }
          delete: {
            args: Prisma.NoteRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>
          }
          update: {
            args: Prisma.NoteRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>
          }
          deleteMany: {
            args: Prisma.NoteRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRequestPayload>
          }
          aggregate: {
            args: Prisma.NoteRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteRequest>
          }
          groupBy: {
            args: Prisma.NoteRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteRequestCountArgs<ExtArgs>
            result: $Utils.Optional<NoteRequestCountAggregateOutputType> | number
          }
        }
      }
      OpenNote: {
        payload: Prisma.$OpenNotePayload<ExtArgs>
        fields: Prisma.OpenNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>
          }
          findFirst: {
            args: Prisma.OpenNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>
          }
          findMany: {
            args: Prisma.OpenNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>[]
          }
          create: {
            args: Prisma.OpenNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>
          }
          createMany: {
            args: Prisma.OpenNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>[]
          }
          delete: {
            args: Prisma.OpenNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>
          }
          update: {
            args: Prisma.OpenNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>
          }
          deleteMany: {
            args: Prisma.OpenNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpenNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenNotePayload>
          }
          aggregate: {
            args: Prisma.OpenNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenNote>
          }
          groupBy: {
            args: Prisma.OpenNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenNoteCountArgs<ExtArgs>
            result: $Utils.Optional<OpenNoteCountAggregateOutputType> | number
          }
        }
      }
      NoteRating: {
        payload: Prisma.$NoteRatingPayload<ExtArgs>
        fields: Prisma.NoteRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>
          }
          findFirst: {
            args: Prisma.NoteRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>
          }
          findMany: {
            args: Prisma.NoteRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>[]
          }
          create: {
            args: Prisma.NoteRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>
          }
          createMany: {
            args: Prisma.NoteRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>[]
          }
          delete: {
            args: Prisma.NoteRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>
          }
          update: {
            args: Prisma.NoteRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>
          }
          deleteMany: {
            args: Prisma.NoteRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteRatingPayload>
          }
          aggregate: {
            args: Prisma.NoteRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteRating>
          }
          groupBy: {
            args: Prisma.NoteRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteRatingCountArgs<ExtArgs>
            result: $Utils.Optional<NoteRatingCountAggregateOutputType> | number
          }
        }
      }
      RequestAggregation: {
        payload: Prisma.$RequestAggregationPayload<ExtArgs>
        fields: Prisma.RequestAggregationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestAggregationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestAggregationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>
          }
          findFirst: {
            args: Prisma.RequestAggregationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestAggregationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>
          }
          findMany: {
            args: Prisma.RequestAggregationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>[]
          }
          create: {
            args: Prisma.RequestAggregationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>
          }
          createMany: {
            args: Prisma.RequestAggregationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestAggregationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>[]
          }
          delete: {
            args: Prisma.RequestAggregationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>
          }
          update: {
            args: Prisma.RequestAggregationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>
          }
          deleteMany: {
            args: Prisma.RequestAggregationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestAggregationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RequestAggregationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAggregationPayload>
          }
          aggregate: {
            args: Prisma.RequestAggregationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestAggregation>
          }
          groupBy: {
            args: Prisma.RequestAggregationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestAggregationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestAggregationCountArgs<ExtArgs>
            result: $Utils.Optional<RequestAggregationCountAggregateOutputType> | number
          }
        }
      }
      RateLimiting: {
        payload: Prisma.$RateLimitingPayload<ExtArgs>
        fields: Prisma.RateLimitingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateLimitingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateLimitingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>
          }
          findFirst: {
            args: Prisma.RateLimitingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateLimitingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>
          }
          findMany: {
            args: Prisma.RateLimitingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>[]
          }
          create: {
            args: Prisma.RateLimitingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>
          }
          createMany: {
            args: Prisma.RateLimitingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RateLimitingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>[]
          }
          delete: {
            args: Prisma.RateLimitingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>
          }
          update: {
            args: Prisma.RateLimitingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>
          }
          deleteMany: {
            args: Prisma.RateLimitingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RateLimitingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RateLimitingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitingPayload>
          }
          aggregate: {
            args: Prisma.RateLimitingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRateLimiting>
          }
          groupBy: {
            args: Prisma.RateLimitingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateLimitingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateLimitingCountArgs<ExtArgs>
            result: $Utils.Optional<RateLimitingCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ModerationQueue: {
        payload: Prisma.$ModerationQueuePayload<ExtArgs>
        fields: Prisma.ModerationQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>
          }
          findFirst: {
            args: Prisma.ModerationQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>
          }
          findMany: {
            args: Prisma.ModerationQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>[]
          }
          create: {
            args: Prisma.ModerationQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>
          }
          createMany: {
            args: Prisma.ModerationQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModerationQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>[]
          }
          delete: {
            args: Prisma.ModerationQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>
          }
          update: {
            args: Prisma.ModerationQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>
          }
          deleteMany: {
            args: Prisma.ModerationQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModerationQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationQueuePayload>
          }
          aggregate: {
            args: Prisma.ModerationQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModerationQueue>
          }
          groupBy: {
            args: Prisma.ModerationQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModerationQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationQueueCountArgs<ExtArgs>
            result: $Utils.Optional<ModerationQueueCountAggregateOutputType> | number
          }
        }
      }
      NotificationQueue: {
        payload: Prisma.$NotificationQueuePayload<ExtArgs>
        fields: Prisma.NotificationQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          findFirst: {
            args: Prisma.NotificationQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          findMany: {
            args: Prisma.NotificationQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          create: {
            args: Prisma.NotificationQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          createMany: {
            args: Prisma.NotificationQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[]
          }
          delete: {
            args: Prisma.NotificationQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          update: {
            args: Prisma.NotificationQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          deleteMany: {
            args: Prisma.NotificationQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>
          }
          aggregate: {
            args: Prisma.NotificationQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationQueue>
          }
          groupBy: {
            args: Prisma.NotificationQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationQueueCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationQueueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    noteRequests: number
    communityNotes: number
    noteRatings: number
    serverMemberships: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    noteRequests?: boolean | UserCountOutputTypeCountNoteRequestsArgs
    communityNotes?: boolean | UserCountOutputTypeCountCommunityNotesArgs
    noteRatings?: boolean | UserCountOutputTypeCountNoteRatingsArgs
    serverMemberships?: boolean | UserCountOutputTypeCountServerMembershipsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServerMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerMemberWhereInput
  }


  /**
   * Count Type ServerCountOutputType
   */

  export type ServerCountOutputType = {
    messages: number
    serverMembers: number
    auditLogs: number
  }

  export type ServerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ServerCountOutputTypeCountMessagesArgs
    serverMembers?: boolean | ServerCountOutputTypeCountServerMembersArgs
    auditLogs?: boolean | ServerCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerCountOutputType
     */
    select?: ServerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeCountServerMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerMemberWhereInput
  }

  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    noteRequests: number
    communityNotes: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    noteRequests?: boolean | MessageCountOutputTypeCountNoteRequestsArgs
    communityNotes?: boolean | MessageCountOutputTypeCountCommunityNotesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountNoteRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteRequestWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountCommunityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenNoteWhereInput
  }


  /**
   * Count Type OpenNoteCountOutputType
   */

  export type OpenNoteCountOutputType = {
    ratings: number
  }

  export type OpenNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ratings?: boolean | OpenNoteCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * OpenNoteCountOutputType without action
   */
  export type OpenNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNoteCountOutputType
     */
    select?: OpenNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpenNoteCountOutputType without action
   */
  export type OpenNoteCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteRatingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    helpfulnessScore: number | null
    totalNotes: number | null
    totalRatings: number | null
    dailyRequestCount: number | null
    batchingInterval: number | null
  }

  export type UserSumAggregateOutputType = {
    helpfulnessScore: number | null
    totalNotes: number | null
    totalRatings: number | null
    dailyRequestCount: number | null
    batchingInterval: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    discordId: string | null
    username: string | null
    discriminator: string | null
    avatar: string | null
    helpfulnessScore: number | null
    totalNotes: number | null
    totalRatings: number | null
    joinedAt: Date | null
    lastActiveAt: Date | null
    dailyRequestCount: number | null
    lastRequestDate: Date | null
    verifiedAt: Date | null
    trustLevel: string | null
    notifyNewRequests: boolean | null
    notifyNotePublished: boolean | null
    notifyNoteRatings: boolean | null
    notifyStatusChanged: boolean | null
    notifyMilestones: boolean | null
    notificationBatching: boolean | null
    batchingInterval: number | null
    notificationsMutedUntil: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    discordId: string | null
    username: string | null
    discriminator: string | null
    avatar: string | null
    helpfulnessScore: number | null
    totalNotes: number | null
    totalRatings: number | null
    joinedAt: Date | null
    lastActiveAt: Date | null
    dailyRequestCount: number | null
    lastRequestDate: Date | null
    verifiedAt: Date | null
    trustLevel: string | null
    notifyNewRequests: boolean | null
    notifyNotePublished: boolean | null
    notifyNoteRatings: boolean | null
    notifyStatusChanged: boolean | null
    notifyMilestones: boolean | null
    notificationBatching: boolean | null
    batchingInterval: number | null
    notificationsMutedUntil: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    discordId: number
    username: number
    discriminator: number
    avatar: number
    helpfulnessScore: number
    totalNotes: number
    totalRatings: number
    joinedAt: number
    lastActiveAt: number
    dailyRequestCount: number
    lastRequestDate: number
    verifiedAt: number
    trustLevel: number
    notifyNewRequests: number
    notifyNotePublished: number
    notifyNoteRatings: number
    notifyStatusChanged: number
    notifyMilestones: number
    notificationBatching: number
    batchingInterval: number
    notificationMethods: number
    notificationsMutedUntil: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    helpfulnessScore?: true
    totalNotes?: true
    totalRatings?: true
    dailyRequestCount?: true
    batchingInterval?: true
  }

  export type UserSumAggregateInputType = {
    helpfulnessScore?: true
    totalNotes?: true
    totalRatings?: true
    dailyRequestCount?: true
    batchingInterval?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    discordId?: true
    username?: true
    discriminator?: true
    avatar?: true
    helpfulnessScore?: true
    totalNotes?: true
    totalRatings?: true
    joinedAt?: true
    lastActiveAt?: true
    dailyRequestCount?: true
    lastRequestDate?: true
    verifiedAt?: true
    trustLevel?: true
    notifyNewRequests?: true
    notifyNotePublished?: true
    notifyNoteRatings?: true
    notifyStatusChanged?: true
    notifyMilestones?: true
    notificationBatching?: true
    batchingInterval?: true
    notificationsMutedUntil?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    discordId?: true
    username?: true
    discriminator?: true
    avatar?: true
    helpfulnessScore?: true
    totalNotes?: true
    totalRatings?: true
    joinedAt?: true
    lastActiveAt?: true
    dailyRequestCount?: true
    lastRequestDate?: true
    verifiedAt?: true
    trustLevel?: true
    notifyNewRequests?: true
    notifyNotePublished?: true
    notifyNoteRatings?: true
    notifyStatusChanged?: true
    notifyMilestones?: true
    notificationBatching?: true
    batchingInterval?: true
    notificationsMutedUntil?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    discordId?: true
    username?: true
    discriminator?: true
    avatar?: true
    helpfulnessScore?: true
    totalNotes?: true
    totalRatings?: true
    joinedAt?: true
    lastActiveAt?: true
    dailyRequestCount?: true
    lastRequestDate?: true
    verifiedAt?: true
    trustLevel?: true
    notifyNewRequests?: true
    notifyNotePublished?: true
    notifyNoteRatings?: true
    notifyStatusChanged?: true
    notifyMilestones?: true
    notificationBatching?: true
    batchingInterval?: true
    notificationMethods?: true
    notificationsMutedUntil?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    discordId: string
    username: string
    discriminator: string | null
    avatar: string | null
    helpfulnessScore: number
    totalNotes: number
    totalRatings: number
    joinedAt: Date
    lastActiveAt: Date
    dailyRequestCount: number
    lastRequestDate: Date | null
    verifiedAt: Date | null
    trustLevel: string
    notifyNewRequests: boolean
    notifyNotePublished: boolean
    notifyNoteRatings: boolean
    notifyStatusChanged: boolean
    notifyMilestones: boolean
    notificationBatching: boolean
    batchingInterval: number
    notificationMethods: string[]
    notificationsMutedUntil: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    username?: boolean
    discriminator?: boolean
    avatar?: boolean
    helpfulnessScore?: boolean
    totalNotes?: boolean
    totalRatings?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    dailyRequestCount?: boolean
    lastRequestDate?: boolean
    verifiedAt?: boolean
    trustLevel?: boolean
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: boolean
    notificationMethods?: boolean
    notificationsMutedUntil?: boolean
    noteRequests?: boolean | User$noteRequestsArgs<ExtArgs>
    communityNotes?: boolean | User$communityNotesArgs<ExtArgs>
    noteRatings?: boolean | User$noteRatingsArgs<ExtArgs>
    serverMemberships?: boolean | User$serverMembershipsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    username?: boolean
    discriminator?: boolean
    avatar?: boolean
    helpfulnessScore?: boolean
    totalNotes?: boolean
    totalRatings?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    dailyRequestCount?: boolean
    lastRequestDate?: boolean
    verifiedAt?: boolean
    trustLevel?: boolean
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: boolean
    notificationMethods?: boolean
    notificationsMutedUntil?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    discordId?: boolean
    username?: boolean
    discriminator?: boolean
    avatar?: boolean
    helpfulnessScore?: boolean
    totalNotes?: boolean
    totalRatings?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    dailyRequestCount?: boolean
    lastRequestDate?: boolean
    verifiedAt?: boolean
    trustLevel?: boolean
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: boolean
    notificationMethods?: boolean
    notificationsMutedUntil?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    noteRequests?: boolean | User$noteRequestsArgs<ExtArgs>
    communityNotes?: boolean | User$communityNotesArgs<ExtArgs>
    noteRatings?: boolean | User$noteRatingsArgs<ExtArgs>
    serverMemberships?: boolean | User$serverMembershipsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      noteRequests: Prisma.$NoteRequestPayload<ExtArgs>[]
      communityNotes: Prisma.$OpenNotePayload<ExtArgs>[]
      noteRatings: Prisma.$NoteRatingPayload<ExtArgs>[]
      serverMemberships: Prisma.$ServerMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      discordId: string
      username: string
      discriminator: string | null
      avatar: string | null
      helpfulnessScore: number
      totalNotes: number
      totalRatings: number
      joinedAt: Date
      lastActiveAt: Date
      dailyRequestCount: number
      lastRequestDate: Date | null
      verifiedAt: Date | null
      trustLevel: string
      notifyNewRequests: boolean
      notifyNotePublished: boolean
      notifyNoteRatings: boolean
      notifyStatusChanged: boolean
      notifyMilestones: boolean
      notificationBatching: boolean
      batchingInterval: number
      notificationMethods: string[]
      notificationsMutedUntil: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    noteRequests<T extends User$noteRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$noteRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findMany"> | Null>
    communityNotes<T extends User$communityNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$communityNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findMany"> | Null>
    noteRatings<T extends User$noteRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$noteRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findMany"> | Null>
    serverMemberships<T extends User$serverMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$serverMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly discordId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly discriminator: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly helpfulnessScore: FieldRef<"User", 'Float'>
    readonly totalNotes: FieldRef<"User", 'Int'>
    readonly totalRatings: FieldRef<"User", 'Int'>
    readonly joinedAt: FieldRef<"User", 'DateTime'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly dailyRequestCount: FieldRef<"User", 'Int'>
    readonly lastRequestDate: FieldRef<"User", 'DateTime'>
    readonly verifiedAt: FieldRef<"User", 'DateTime'>
    readonly trustLevel: FieldRef<"User", 'String'>
    readonly notifyNewRequests: FieldRef<"User", 'Boolean'>
    readonly notifyNotePublished: FieldRef<"User", 'Boolean'>
    readonly notifyNoteRatings: FieldRef<"User", 'Boolean'>
    readonly notifyStatusChanged: FieldRef<"User", 'Boolean'>
    readonly notifyMilestones: FieldRef<"User", 'Boolean'>
    readonly notificationBatching: FieldRef<"User", 'Boolean'>
    readonly batchingInterval: FieldRef<"User", 'Int'>
    readonly notificationMethods: FieldRef<"User", 'String[]'>
    readonly notificationsMutedUntil: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.noteRequests
   */
  export type User$noteRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    where?: NoteRequestWhereInput
    orderBy?: NoteRequestOrderByWithRelationInput | NoteRequestOrderByWithRelationInput[]
    cursor?: NoteRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteRequestScalarFieldEnum | NoteRequestScalarFieldEnum[]
  }

  /**
   * User.communityNotes
   */
  export type User$communityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    where?: OpenNoteWhereInput
    orderBy?: OpenNoteOrderByWithRelationInput | OpenNoteOrderByWithRelationInput[]
    cursor?: OpenNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenNoteScalarFieldEnum | OpenNoteScalarFieldEnum[]
  }

  /**
   * User.noteRatings
   */
  export type User$noteRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    where?: NoteRatingWhereInput
    orderBy?: NoteRatingOrderByWithRelationInput | NoteRatingOrderByWithRelationInput[]
    cursor?: NoteRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteRatingScalarFieldEnum | NoteRatingScalarFieldEnum[]
  }

  /**
   * User.serverMemberships
   */
  export type User$serverMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    where?: ServerMemberWhereInput
    orderBy?: ServerMemberOrderByWithRelationInput | ServerMemberOrderByWithRelationInput[]
    cursor?: ServerMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServerMemberScalarFieldEnum | ServerMemberScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Server
   */

  export type AggregateServer = {
    _count: ServerCountAggregateOutputType | null
    _avg: ServerAvgAggregateOutputType | null
    _sum: ServerSumAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  export type ServerAvgAggregateOutputType = {
    maxRequestsPerUser: number | null
  }

  export type ServerSumAggregateOutputType = {
    maxRequestsPerUser: number | null
  }

  export type ServerMinAggregateOutputType = {
    id: string | null
    discordId: string | null
    name: string | null
    icon: string | null
    enabled: boolean | null
    joinedAt: Date | null
    allowNoteRequests: boolean | null
    allowNoteCreation: boolean | null
    maxRequestsPerUser: number | null
    requireVerification: boolean | null
    isPaused: boolean | null
    pausedAt: Date | null
    pausedBy: string | null
    pauseReason: string | null
  }

  export type ServerMaxAggregateOutputType = {
    id: string | null
    discordId: string | null
    name: string | null
    icon: string | null
    enabled: boolean | null
    joinedAt: Date | null
    allowNoteRequests: boolean | null
    allowNoteCreation: boolean | null
    maxRequestsPerUser: number | null
    requireVerification: boolean | null
    isPaused: boolean | null
    pausedAt: Date | null
    pausedBy: string | null
    pauseReason: string | null
  }

  export type ServerCountAggregateOutputType = {
    id: number
    discordId: number
    name: number
    icon: number
    enabled: number
    joinedAt: number
    allowNoteRequests: number
    allowNoteCreation: number
    maxRequestsPerUser: number
    requireVerification: number
    enabledChannels: number
    disabledChannels: number
    moderatorRoles: number
    contributorRoles: number
    isPaused: number
    pausedAt: number
    pausedBy: number
    pauseReason: number
    _all: number
  }


  export type ServerAvgAggregateInputType = {
    maxRequestsPerUser?: true
  }

  export type ServerSumAggregateInputType = {
    maxRequestsPerUser?: true
  }

  export type ServerMinAggregateInputType = {
    id?: true
    discordId?: true
    name?: true
    icon?: true
    enabled?: true
    joinedAt?: true
    allowNoteRequests?: true
    allowNoteCreation?: true
    maxRequestsPerUser?: true
    requireVerification?: true
    isPaused?: true
    pausedAt?: true
    pausedBy?: true
    pauseReason?: true
  }

  export type ServerMaxAggregateInputType = {
    id?: true
    discordId?: true
    name?: true
    icon?: true
    enabled?: true
    joinedAt?: true
    allowNoteRequests?: true
    allowNoteCreation?: true
    maxRequestsPerUser?: true
    requireVerification?: true
    isPaused?: true
    pausedAt?: true
    pausedBy?: true
    pauseReason?: true
  }

  export type ServerCountAggregateInputType = {
    id?: true
    discordId?: true
    name?: true
    icon?: true
    enabled?: true
    joinedAt?: true
    allowNoteRequests?: true
    allowNoteCreation?: true
    maxRequestsPerUser?: true
    requireVerification?: true
    enabledChannels?: true
    disabledChannels?: true
    moderatorRoles?: true
    contributorRoles?: true
    isPaused?: true
    pausedAt?: true
    pausedBy?: true
    pauseReason?: true
    _all?: true
  }

  export type ServerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Server to aggregate.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servers
    **/
    _count?: true | ServerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServerMaxAggregateInputType
  }

  export type GetServerAggregateType<T extends ServerAggregateArgs> = {
        [P in keyof T & keyof AggregateServer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer[P]>
      : GetScalarType<T[P], AggregateServer[P]>
  }




  export type ServerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerWhereInput
    orderBy?: ServerOrderByWithAggregationInput | ServerOrderByWithAggregationInput[]
    by: ServerScalarFieldEnum[] | ServerScalarFieldEnum
    having?: ServerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServerCountAggregateInputType | true
    _avg?: ServerAvgAggregateInputType
    _sum?: ServerSumAggregateInputType
    _min?: ServerMinAggregateInputType
    _max?: ServerMaxAggregateInputType
  }

  export type ServerGroupByOutputType = {
    id: string
    discordId: string
    name: string
    icon: string | null
    enabled: boolean
    joinedAt: Date
    allowNoteRequests: boolean
    allowNoteCreation: boolean
    maxRequestsPerUser: number
    requireVerification: boolean
    enabledChannels: string[]
    disabledChannels: string[]
    moderatorRoles: string[]
    contributorRoles: string[]
    isPaused: boolean
    pausedAt: Date | null
    pausedBy: string | null
    pauseReason: string | null
    _count: ServerCountAggregateOutputType | null
    _avg: ServerAvgAggregateOutputType | null
    _sum: ServerSumAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  type GetServerGroupByPayload<T extends ServerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServerGroupByOutputType[P]>
            : GetScalarType<T[P], ServerGroupByOutputType[P]>
        }
      >
    >


  export type ServerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    name?: boolean
    icon?: boolean
    enabled?: boolean
    joinedAt?: boolean
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: boolean
    requireVerification?: boolean
    enabledChannels?: boolean
    disabledChannels?: boolean
    moderatorRoles?: boolean
    contributorRoles?: boolean
    isPaused?: boolean
    pausedAt?: boolean
    pausedBy?: boolean
    pauseReason?: boolean
    messages?: boolean | Server$messagesArgs<ExtArgs>
    serverMembers?: boolean | Server$serverMembersArgs<ExtArgs>
    auditLogs?: boolean | Server$auditLogsArgs<ExtArgs>
    _count?: boolean | ServerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["server"]>

  export type ServerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    name?: boolean
    icon?: boolean
    enabled?: boolean
    joinedAt?: boolean
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: boolean
    requireVerification?: boolean
    enabledChannels?: boolean
    disabledChannels?: boolean
    moderatorRoles?: boolean
    contributorRoles?: boolean
    isPaused?: boolean
    pausedAt?: boolean
    pausedBy?: boolean
    pauseReason?: boolean
  }, ExtArgs["result"]["server"]>

  export type ServerSelectScalar = {
    id?: boolean
    discordId?: boolean
    name?: boolean
    icon?: boolean
    enabled?: boolean
    joinedAt?: boolean
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: boolean
    requireVerification?: boolean
    enabledChannels?: boolean
    disabledChannels?: boolean
    moderatorRoles?: boolean
    contributorRoles?: boolean
    isPaused?: boolean
    pausedAt?: boolean
    pausedBy?: boolean
    pauseReason?: boolean
  }

  export type ServerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Server$messagesArgs<ExtArgs>
    serverMembers?: boolean | Server$serverMembersArgs<ExtArgs>
    auditLogs?: boolean | Server$auditLogsArgs<ExtArgs>
    _count?: boolean | ServerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Server"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      serverMembers: Prisma.$ServerMemberPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      discordId: string
      name: string
      icon: string | null
      enabled: boolean
      joinedAt: Date
      allowNoteRequests: boolean
      allowNoteCreation: boolean
      maxRequestsPerUser: number
      requireVerification: boolean
      enabledChannels: string[]
      disabledChannels: string[]
      moderatorRoles: string[]
      contributorRoles: string[]
      isPaused: boolean
      pausedAt: Date | null
      pausedBy: string | null
      pauseReason: string | null
    }, ExtArgs["result"]["server"]>
    composites: {}
  }

  type ServerGetPayload<S extends boolean | null | undefined | ServerDefaultArgs> = $Result.GetResult<Prisma.$ServerPayload, S>

  type ServerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServerCountAggregateInputType | true
    }

  export interface ServerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Server'], meta: { name: 'Server' } }
    /**
     * Find zero or one Server that matches the filter.
     * @param {ServerFindUniqueArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServerFindUniqueArgs>(args: SelectSubset<T, ServerFindUniqueArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Server that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServerFindUniqueOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServerFindUniqueOrThrowArgs>(args: SelectSubset<T, ServerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Server that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindFirstArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServerFindFirstArgs>(args?: SelectSubset<T, ServerFindFirstArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Server that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindFirstOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServerFindFirstOrThrowArgs>(args?: SelectSubset<T, ServerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servers
     * const servers = await prisma.server.findMany()
     * 
     * // Get first 10 Servers
     * const servers = await prisma.server.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serverWithIdOnly = await prisma.server.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServerFindManyArgs>(args?: SelectSubset<T, ServerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Server.
     * @param {ServerCreateArgs} args - Arguments to create a Server.
     * @example
     * // Create one Server
     * const Server = await prisma.server.create({
     *   data: {
     *     // ... data to create a Server
     *   }
     * })
     * 
     */
    create<T extends ServerCreateArgs>(args: SelectSubset<T, ServerCreateArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servers.
     * @param {ServerCreateManyArgs} args - Arguments to create many Servers.
     * @example
     * // Create many Servers
     * const server = await prisma.server.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServerCreateManyArgs>(args?: SelectSubset<T, ServerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servers and returns the data saved in the database.
     * @param {ServerCreateManyAndReturnArgs} args - Arguments to create many Servers.
     * @example
     * // Create many Servers
     * const server = await prisma.server.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servers and only return the `id`
     * const serverWithIdOnly = await prisma.server.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServerCreateManyAndReturnArgs>(args?: SelectSubset<T, ServerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Server.
     * @param {ServerDeleteArgs} args - Arguments to delete one Server.
     * @example
     * // Delete one Server
     * const Server = await prisma.server.delete({
     *   where: {
     *     // ... filter to delete one Server
     *   }
     * })
     * 
     */
    delete<T extends ServerDeleteArgs>(args: SelectSubset<T, ServerDeleteArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Server.
     * @param {ServerUpdateArgs} args - Arguments to update one Server.
     * @example
     * // Update one Server
     * const server = await prisma.server.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServerUpdateArgs>(args: SelectSubset<T, ServerUpdateArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servers.
     * @param {ServerDeleteManyArgs} args - Arguments to filter Servers to delete.
     * @example
     * // Delete a few Servers
     * const { count } = await prisma.server.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServerDeleteManyArgs>(args?: SelectSubset<T, ServerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servers
     * const server = await prisma.server.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServerUpdateManyArgs>(args: SelectSubset<T, ServerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server.
     * @param {ServerUpsertArgs} args - Arguments to update or create a Server.
     * @example
     * // Update or create a Server
     * const server = await prisma.server.upsert({
     *   create: {
     *     // ... data to create a Server
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server we want to update
     *   }
     * })
     */
    upsert<T extends ServerUpsertArgs>(args: SelectSubset<T, ServerUpsertArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerCountArgs} args - Arguments to filter Servers to count.
     * @example
     * // Count the number of Servers
     * const count = await prisma.server.count({
     *   where: {
     *     // ... the filter for the Servers we want to count
     *   }
     * })
    **/
    count<T extends ServerCountArgs>(
      args?: Subset<T, ServerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServerAggregateArgs>(args: Subset<T, ServerAggregateArgs>): Prisma.PrismaPromise<GetServerAggregateType<T>>

    /**
     * Group by Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServerGroupByArgs['orderBy'] }
        : { orderBy?: ServerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Server model
   */
  readonly fields: ServerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Server.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Server$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Server$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    serverMembers<T extends Server$serverMembersArgs<ExtArgs> = {}>(args?: Subset<T, Server$serverMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Server$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Server$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Server model
   */ 
  interface ServerFieldRefs {
    readonly id: FieldRef<"Server", 'String'>
    readonly discordId: FieldRef<"Server", 'String'>
    readonly name: FieldRef<"Server", 'String'>
    readonly icon: FieldRef<"Server", 'String'>
    readonly enabled: FieldRef<"Server", 'Boolean'>
    readonly joinedAt: FieldRef<"Server", 'DateTime'>
    readonly allowNoteRequests: FieldRef<"Server", 'Boolean'>
    readonly allowNoteCreation: FieldRef<"Server", 'Boolean'>
    readonly maxRequestsPerUser: FieldRef<"Server", 'Int'>
    readonly requireVerification: FieldRef<"Server", 'Boolean'>
    readonly enabledChannels: FieldRef<"Server", 'String[]'>
    readonly disabledChannels: FieldRef<"Server", 'String[]'>
    readonly moderatorRoles: FieldRef<"Server", 'String[]'>
    readonly contributorRoles: FieldRef<"Server", 'String[]'>
    readonly isPaused: FieldRef<"Server", 'Boolean'>
    readonly pausedAt: FieldRef<"Server", 'DateTime'>
    readonly pausedBy: FieldRef<"Server", 'String'>
    readonly pauseReason: FieldRef<"Server", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Server findUnique
   */
  export type ServerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server findUniqueOrThrow
   */
  export type ServerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server findFirst
   */
  export type ServerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * Server findFirstOrThrow
   */
  export type ServerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * Server findMany
   */
  export type ServerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter, which Servers to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * Server create
   */
  export type ServerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * The data needed to create a Server.
     */
    data: XOR<ServerCreateInput, ServerUncheckedCreateInput>
  }

  /**
   * Server createMany
   */
  export type ServerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servers.
     */
    data: ServerCreateManyInput | ServerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Server createManyAndReturn
   */
  export type ServerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Servers.
     */
    data: ServerCreateManyInput | ServerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Server update
   */
  export type ServerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * The data needed to update a Server.
     */
    data: XOR<ServerUpdateInput, ServerUncheckedUpdateInput>
    /**
     * Choose, which Server to update.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server updateMany
   */
  export type ServerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servers.
     */
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyInput>
    /**
     * Filter which Servers to update
     */
    where?: ServerWhereInput
  }

  /**
   * Server upsert
   */
  export type ServerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * The filter to search for the Server to update in case it exists.
     */
    where: ServerWhereUniqueInput
    /**
     * In case the Server found by the `where` argument doesn't exist, create a new Server with this data.
     */
    create: XOR<ServerCreateInput, ServerUncheckedCreateInput>
    /**
     * In case the Server was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServerUpdateInput, ServerUncheckedUpdateInput>
  }

  /**
   * Server delete
   */
  export type ServerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
    /**
     * Filter which Server to delete.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server deleteMany
   */
  export type ServerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servers to delete
     */
    where?: ServerWhereInput
  }

  /**
   * Server.messages
   */
  export type Server$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Server.serverMembers
   */
  export type Server$serverMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    where?: ServerMemberWhereInput
    orderBy?: ServerMemberOrderByWithRelationInput | ServerMemberOrderByWithRelationInput[]
    cursor?: ServerMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServerMemberScalarFieldEnum | ServerMemberScalarFieldEnum[]
  }

  /**
   * Server.auditLogs
   */
  export type Server$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Server without action
   */
  export type ServerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerInclude<ExtArgs> | null
  }


  /**
   * Model ServerMember
   */

  export type AggregateServerMember = {
    _count: ServerMemberCountAggregateOutputType | null
    _min: ServerMemberMinAggregateOutputType | null
    _max: ServerMemberMaxAggregateOutputType | null
  }

  export type ServerMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serverId: string | null
    joinedAt: Date | null
  }

  export type ServerMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serverId: string | null
    joinedAt: Date | null
  }

  export type ServerMemberCountAggregateOutputType = {
    id: number
    userId: number
    serverId: number
    roles: number
    joinedAt: number
    _all: number
  }


  export type ServerMemberMinAggregateInputType = {
    id?: true
    userId?: true
    serverId?: true
    joinedAt?: true
  }

  export type ServerMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    serverId?: true
    joinedAt?: true
  }

  export type ServerMemberCountAggregateInputType = {
    id?: true
    userId?: true
    serverId?: true
    roles?: true
    joinedAt?: true
    _all?: true
  }

  export type ServerMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServerMember to aggregate.
     */
    where?: ServerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServerMembers to fetch.
     */
    orderBy?: ServerMemberOrderByWithRelationInput | ServerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServerMembers
    **/
    _count?: true | ServerMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServerMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServerMemberMaxAggregateInputType
  }

  export type GetServerMemberAggregateType<T extends ServerMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateServerMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServerMember[P]>
      : GetScalarType<T[P], AggregateServerMember[P]>
  }




  export type ServerMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerMemberWhereInput
    orderBy?: ServerMemberOrderByWithAggregationInput | ServerMemberOrderByWithAggregationInput[]
    by: ServerMemberScalarFieldEnum[] | ServerMemberScalarFieldEnum
    having?: ServerMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServerMemberCountAggregateInputType | true
    _min?: ServerMemberMinAggregateInputType
    _max?: ServerMemberMaxAggregateInputType
  }

  export type ServerMemberGroupByOutputType = {
    id: string
    userId: string
    serverId: string
    roles: string[]
    joinedAt: Date
    _count: ServerMemberCountAggregateOutputType | null
    _min: ServerMemberMinAggregateOutputType | null
    _max: ServerMemberMaxAggregateOutputType | null
  }

  type GetServerMemberGroupByPayload<T extends ServerMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServerMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServerMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServerMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ServerMemberGroupByOutputType[P]>
        }
      >
    >


  export type ServerMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serverId?: boolean
    roles?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serverMember"]>

  export type ServerMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serverId?: boolean
    roles?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serverMember"]>

  export type ServerMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    serverId?: boolean
    roles?: boolean
    joinedAt?: boolean
  }

  export type ServerMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }
  export type ServerMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }

  export type $ServerMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServerMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      server: Prisma.$ServerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serverId: string
      roles: string[]
      joinedAt: Date
    }, ExtArgs["result"]["serverMember"]>
    composites: {}
  }

  type ServerMemberGetPayload<S extends boolean | null | undefined | ServerMemberDefaultArgs> = $Result.GetResult<Prisma.$ServerMemberPayload, S>

  type ServerMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServerMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServerMemberCountAggregateInputType | true
    }

  export interface ServerMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServerMember'], meta: { name: 'ServerMember' } }
    /**
     * Find zero or one ServerMember that matches the filter.
     * @param {ServerMemberFindUniqueArgs} args - Arguments to find a ServerMember
     * @example
     * // Get one ServerMember
     * const serverMember = await prisma.serverMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServerMemberFindUniqueArgs>(args: SelectSubset<T, ServerMemberFindUniqueArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServerMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServerMemberFindUniqueOrThrowArgs} args - Arguments to find a ServerMember
     * @example
     * // Get one ServerMember
     * const serverMember = await prisma.serverMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServerMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ServerMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServerMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberFindFirstArgs} args - Arguments to find a ServerMember
     * @example
     * // Get one ServerMember
     * const serverMember = await prisma.serverMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServerMemberFindFirstArgs>(args?: SelectSubset<T, ServerMemberFindFirstArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServerMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberFindFirstOrThrowArgs} args - Arguments to find a ServerMember
     * @example
     * // Get one ServerMember
     * const serverMember = await prisma.serverMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServerMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ServerMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServerMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServerMembers
     * const serverMembers = await prisma.serverMember.findMany()
     * 
     * // Get first 10 ServerMembers
     * const serverMembers = await prisma.serverMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serverMemberWithIdOnly = await prisma.serverMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServerMemberFindManyArgs>(args?: SelectSubset<T, ServerMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServerMember.
     * @param {ServerMemberCreateArgs} args - Arguments to create a ServerMember.
     * @example
     * // Create one ServerMember
     * const ServerMember = await prisma.serverMember.create({
     *   data: {
     *     // ... data to create a ServerMember
     *   }
     * })
     * 
     */
    create<T extends ServerMemberCreateArgs>(args: SelectSubset<T, ServerMemberCreateArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServerMembers.
     * @param {ServerMemberCreateManyArgs} args - Arguments to create many ServerMembers.
     * @example
     * // Create many ServerMembers
     * const serverMember = await prisma.serverMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServerMemberCreateManyArgs>(args?: SelectSubset<T, ServerMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServerMembers and returns the data saved in the database.
     * @param {ServerMemberCreateManyAndReturnArgs} args - Arguments to create many ServerMembers.
     * @example
     * // Create many ServerMembers
     * const serverMember = await prisma.serverMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServerMembers and only return the `id`
     * const serverMemberWithIdOnly = await prisma.serverMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServerMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ServerMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServerMember.
     * @param {ServerMemberDeleteArgs} args - Arguments to delete one ServerMember.
     * @example
     * // Delete one ServerMember
     * const ServerMember = await prisma.serverMember.delete({
     *   where: {
     *     // ... filter to delete one ServerMember
     *   }
     * })
     * 
     */
    delete<T extends ServerMemberDeleteArgs>(args: SelectSubset<T, ServerMemberDeleteArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServerMember.
     * @param {ServerMemberUpdateArgs} args - Arguments to update one ServerMember.
     * @example
     * // Update one ServerMember
     * const serverMember = await prisma.serverMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServerMemberUpdateArgs>(args: SelectSubset<T, ServerMemberUpdateArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServerMembers.
     * @param {ServerMemberDeleteManyArgs} args - Arguments to filter ServerMembers to delete.
     * @example
     * // Delete a few ServerMembers
     * const { count } = await prisma.serverMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServerMemberDeleteManyArgs>(args?: SelectSubset<T, ServerMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServerMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServerMembers
     * const serverMember = await prisma.serverMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServerMemberUpdateManyArgs>(args: SelectSubset<T, ServerMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServerMember.
     * @param {ServerMemberUpsertArgs} args - Arguments to update or create a ServerMember.
     * @example
     * // Update or create a ServerMember
     * const serverMember = await prisma.serverMember.upsert({
     *   create: {
     *     // ... data to create a ServerMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServerMember we want to update
     *   }
     * })
     */
    upsert<T extends ServerMemberUpsertArgs>(args: SelectSubset<T, ServerMemberUpsertArgs<ExtArgs>>): Prisma__ServerMemberClient<$Result.GetResult<Prisma.$ServerMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServerMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberCountArgs} args - Arguments to filter ServerMembers to count.
     * @example
     * // Count the number of ServerMembers
     * const count = await prisma.serverMember.count({
     *   where: {
     *     // ... the filter for the ServerMembers we want to count
     *   }
     * })
    **/
    count<T extends ServerMemberCountArgs>(
      args?: Subset<T, ServerMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServerMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServerMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServerMemberAggregateArgs>(args: Subset<T, ServerMemberAggregateArgs>): Prisma.PrismaPromise<GetServerMemberAggregateType<T>>

    /**
     * Group by ServerMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServerMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServerMemberGroupByArgs['orderBy'] }
        : { orderBy?: ServerMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServerMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServerMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServerMember model
   */
  readonly fields: ServerMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServerMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServerMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    server<T extends ServerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServerDefaultArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServerMember model
   */ 
  interface ServerMemberFieldRefs {
    readonly id: FieldRef<"ServerMember", 'String'>
    readonly userId: FieldRef<"ServerMember", 'String'>
    readonly serverId: FieldRef<"ServerMember", 'String'>
    readonly roles: FieldRef<"ServerMember", 'String[]'>
    readonly joinedAt: FieldRef<"ServerMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServerMember findUnique
   */
  export type ServerMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * Filter, which ServerMember to fetch.
     */
    where: ServerMemberWhereUniqueInput
  }

  /**
   * ServerMember findUniqueOrThrow
   */
  export type ServerMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * Filter, which ServerMember to fetch.
     */
    where: ServerMemberWhereUniqueInput
  }

  /**
   * ServerMember findFirst
   */
  export type ServerMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * Filter, which ServerMember to fetch.
     */
    where?: ServerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServerMembers to fetch.
     */
    orderBy?: ServerMemberOrderByWithRelationInput | ServerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServerMembers.
     */
    cursor?: ServerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServerMembers.
     */
    distinct?: ServerMemberScalarFieldEnum | ServerMemberScalarFieldEnum[]
  }

  /**
   * ServerMember findFirstOrThrow
   */
  export type ServerMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * Filter, which ServerMember to fetch.
     */
    where?: ServerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServerMembers to fetch.
     */
    orderBy?: ServerMemberOrderByWithRelationInput | ServerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServerMembers.
     */
    cursor?: ServerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServerMembers.
     */
    distinct?: ServerMemberScalarFieldEnum | ServerMemberScalarFieldEnum[]
  }

  /**
   * ServerMember findMany
   */
  export type ServerMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * Filter, which ServerMembers to fetch.
     */
    where?: ServerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServerMembers to fetch.
     */
    orderBy?: ServerMemberOrderByWithRelationInput | ServerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServerMembers.
     */
    cursor?: ServerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServerMembers.
     */
    skip?: number
    distinct?: ServerMemberScalarFieldEnum | ServerMemberScalarFieldEnum[]
  }

  /**
   * ServerMember create
   */
  export type ServerMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ServerMember.
     */
    data: XOR<ServerMemberCreateInput, ServerMemberUncheckedCreateInput>
  }

  /**
   * ServerMember createMany
   */
  export type ServerMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServerMembers.
     */
    data: ServerMemberCreateManyInput | ServerMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServerMember createManyAndReturn
   */
  export type ServerMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServerMembers.
     */
    data: ServerMemberCreateManyInput | ServerMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServerMember update
   */
  export type ServerMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ServerMember.
     */
    data: XOR<ServerMemberUpdateInput, ServerMemberUncheckedUpdateInput>
    /**
     * Choose, which ServerMember to update.
     */
    where: ServerMemberWhereUniqueInput
  }

  /**
   * ServerMember updateMany
   */
  export type ServerMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServerMembers.
     */
    data: XOR<ServerMemberUpdateManyMutationInput, ServerMemberUncheckedUpdateManyInput>
    /**
     * Filter which ServerMembers to update
     */
    where?: ServerMemberWhereInput
  }

  /**
   * ServerMember upsert
   */
  export type ServerMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ServerMember to update in case it exists.
     */
    where: ServerMemberWhereUniqueInput
    /**
     * In case the ServerMember found by the `where` argument doesn't exist, create a new ServerMember with this data.
     */
    create: XOR<ServerMemberCreateInput, ServerMemberUncheckedCreateInput>
    /**
     * In case the ServerMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServerMemberUpdateInput, ServerMemberUncheckedUpdateInput>
  }

  /**
   * ServerMember delete
   */
  export type ServerMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
    /**
     * Filter which ServerMember to delete.
     */
    where: ServerMemberWhereUniqueInput
  }

  /**
   * ServerMember deleteMany
   */
  export type ServerMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServerMembers to delete
     */
    where?: ServerMemberWhereInput
  }

  /**
   * ServerMember without action
   */
  export type ServerMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerMember
     */
    select?: ServerMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServerMemberInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    totalRequests: number | null
    uniqueRequestors: number | null
  }

  export type MessageSumAggregateOutputType = {
    totalRequests: number | null
    uniqueRequestors: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    discordId: string | null
    channelId: string | null
    serverId: string | null
    authorId: string | null
    content: string | null
    timestamp: Date | null
    createdAt: Date | null
    totalRequests: number | null
    uniqueRequestors: number | null
    hasActiveNote: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    discordId: string | null
    channelId: string | null
    serverId: string | null
    authorId: string | null
    content: string | null
    timestamp: Date | null
    createdAt: Date | null
    totalRequests: number | null
    uniqueRequestors: number | null
    hasActiveNote: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    discordId: number
    channelId: number
    serverId: number
    authorId: number
    content: number
    attachments: number
    timestamp: number
    createdAt: number
    totalRequests: number
    uniqueRequestors: number
    hasActiveNote: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    totalRequests?: true
    uniqueRequestors?: true
  }

  export type MessageSumAggregateInputType = {
    totalRequests?: true
    uniqueRequestors?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    discordId?: true
    channelId?: true
    serverId?: true
    authorId?: true
    content?: true
    timestamp?: true
    createdAt?: true
    totalRequests?: true
    uniqueRequestors?: true
    hasActiveNote?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    discordId?: true
    channelId?: true
    serverId?: true
    authorId?: true
    content?: true
    timestamp?: true
    createdAt?: true
    totalRequests?: true
    uniqueRequestors?: true
    hasActiveNote?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    discordId?: true
    channelId?: true
    serverId?: true
    authorId?: true
    content?: true
    attachments?: true
    timestamp?: true
    createdAt?: true
    totalRequests?: true
    uniqueRequestors?: true
    hasActiveNote?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    discordId: string
    channelId: string
    serverId: string
    authorId: string
    content: string
    attachments: string[]
    timestamp: Date
    createdAt: Date
    totalRequests: number
    uniqueRequestors: number
    hasActiveNote: boolean
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    channelId?: boolean
    serverId?: boolean
    authorId?: boolean
    content?: boolean
    attachments?: boolean
    timestamp?: boolean
    createdAt?: boolean
    totalRequests?: boolean
    uniqueRequestors?: boolean
    hasActiveNote?: boolean
    server?: boolean | ServerDefaultArgs<ExtArgs>
    noteRequests?: boolean | Message$noteRequestsArgs<ExtArgs>
    communityNotes?: boolean | Message$communityNotesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordId?: boolean
    channelId?: boolean
    serverId?: boolean
    authorId?: boolean
    content?: boolean
    attachments?: boolean
    timestamp?: boolean
    createdAt?: boolean
    totalRequests?: boolean
    uniqueRequestors?: boolean
    hasActiveNote?: boolean
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    discordId?: boolean
    channelId?: boolean
    serverId?: boolean
    authorId?: boolean
    content?: boolean
    attachments?: boolean
    timestamp?: boolean
    createdAt?: boolean
    totalRequests?: boolean
    uniqueRequestors?: boolean
    hasActiveNote?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | ServerDefaultArgs<ExtArgs>
    noteRequests?: boolean | Message$noteRequestsArgs<ExtArgs>
    communityNotes?: boolean | Message$communityNotesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      server: Prisma.$ServerPayload<ExtArgs>
      noteRequests: Prisma.$NoteRequestPayload<ExtArgs>[]
      communityNotes: Prisma.$OpenNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      discordId: string
      channelId: string
      serverId: string
      authorId: string
      content: string
      attachments: string[]
      timestamp: Date
      createdAt: Date
      totalRequests: number
      uniqueRequestors: number
      hasActiveNote: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    server<T extends ServerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServerDefaultArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    noteRequests<T extends Message$noteRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Message$noteRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findMany"> | Null>
    communityNotes<T extends Message$communityNotesArgs<ExtArgs> = {}>(args?: Subset<T, Message$communityNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly discordId: FieldRef<"Message", 'String'>
    readonly channelId: FieldRef<"Message", 'String'>
    readonly serverId: FieldRef<"Message", 'String'>
    readonly authorId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'String[]'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly totalRequests: FieldRef<"Message", 'Int'>
    readonly uniqueRequestors: FieldRef<"Message", 'Int'>
    readonly hasActiveNote: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.noteRequests
   */
  export type Message$noteRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    where?: NoteRequestWhereInput
    orderBy?: NoteRequestOrderByWithRelationInput | NoteRequestOrderByWithRelationInput[]
    cursor?: NoteRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteRequestScalarFieldEnum | NoteRequestScalarFieldEnum[]
  }

  /**
   * Message.communityNotes
   */
  export type Message$communityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    where?: OpenNoteWhereInput
    orderBy?: OpenNoteOrderByWithRelationInput | OpenNoteOrderByWithRelationInput[]
    cursor?: OpenNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenNoteScalarFieldEnum | OpenNoteScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model NoteRequest
   */

  export type AggregateNoteRequest = {
    _count: NoteRequestCountAggregateOutputType | null
    _min: NoteRequestMinAggregateOutputType | null
    _max: NoteRequestMaxAggregateOutputType | null
  }

  export type NoteRequestMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    requestorId: string | null
    reason: string | null
    timestamp: Date | null
    isActive: boolean | null
  }

  export type NoteRequestMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    requestorId: string | null
    reason: string | null
    timestamp: Date | null
    isActive: boolean | null
  }

  export type NoteRequestCountAggregateOutputType = {
    id: number
    messageId: number
    requestorId: number
    reason: number
    sources: number
    timestamp: number
    isActive: number
    _all: number
  }


  export type NoteRequestMinAggregateInputType = {
    id?: true
    messageId?: true
    requestorId?: true
    reason?: true
    timestamp?: true
    isActive?: true
  }

  export type NoteRequestMaxAggregateInputType = {
    id?: true
    messageId?: true
    requestorId?: true
    reason?: true
    timestamp?: true
    isActive?: true
  }

  export type NoteRequestCountAggregateInputType = {
    id?: true
    messageId?: true
    requestorId?: true
    reason?: true
    sources?: true
    timestamp?: true
    isActive?: true
    _all?: true
  }

  export type NoteRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteRequest to aggregate.
     */
    where?: NoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRequests to fetch.
     */
    orderBy?: NoteRequestOrderByWithRelationInput | NoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteRequests
    **/
    _count?: true | NoteRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteRequestMaxAggregateInputType
  }

  export type GetNoteRequestAggregateType<T extends NoteRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteRequest[P]>
      : GetScalarType<T[P], AggregateNoteRequest[P]>
  }




  export type NoteRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteRequestWhereInput
    orderBy?: NoteRequestOrderByWithAggregationInput | NoteRequestOrderByWithAggregationInput[]
    by: NoteRequestScalarFieldEnum[] | NoteRequestScalarFieldEnum
    having?: NoteRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteRequestCountAggregateInputType | true
    _min?: NoteRequestMinAggregateInputType
    _max?: NoteRequestMaxAggregateInputType
  }

  export type NoteRequestGroupByOutputType = {
    id: string
    messageId: string
    requestorId: string
    reason: string | null
    sources: string[]
    timestamp: Date
    isActive: boolean
    _count: NoteRequestCountAggregateOutputType | null
    _min: NoteRequestMinAggregateOutputType | null
    _max: NoteRequestMaxAggregateOutputType | null
  }

  type GetNoteRequestGroupByPayload<T extends NoteRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteRequestGroupByOutputType[P]>
            : GetScalarType<T[P], NoteRequestGroupByOutputType[P]>
        }
      >
    >


  export type NoteRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    requestorId?: boolean
    reason?: boolean
    sources?: boolean
    timestamp?: boolean
    isActive?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    requestor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteRequest"]>

  export type NoteRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    requestorId?: boolean
    reason?: boolean
    sources?: boolean
    timestamp?: boolean
    isActive?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    requestor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteRequest"]>

  export type NoteRequestSelectScalar = {
    id?: boolean
    messageId?: boolean
    requestorId?: boolean
    reason?: boolean
    sources?: boolean
    timestamp?: boolean
    isActive?: boolean
  }

  export type NoteRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    requestor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    requestor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NoteRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteRequest"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      requestor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      requestorId: string
      reason: string | null
      sources: string[]
      timestamp: Date
      isActive: boolean
    }, ExtArgs["result"]["noteRequest"]>
    composites: {}
  }

  type NoteRequestGetPayload<S extends boolean | null | undefined | NoteRequestDefaultArgs> = $Result.GetResult<Prisma.$NoteRequestPayload, S>

  type NoteRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteRequestCountAggregateInputType | true
    }

  export interface NoteRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteRequest'], meta: { name: 'NoteRequest' } }
    /**
     * Find zero or one NoteRequest that matches the filter.
     * @param {NoteRequestFindUniqueArgs} args - Arguments to find a NoteRequest
     * @example
     * // Get one NoteRequest
     * const noteRequest = await prisma.noteRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteRequestFindUniqueArgs>(args: SelectSubset<T, NoteRequestFindUniqueArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NoteRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteRequestFindUniqueOrThrowArgs} args - Arguments to find a NoteRequest
     * @example
     * // Get one NoteRequest
     * const noteRequest = await prisma.noteRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NoteRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestFindFirstArgs} args - Arguments to find a NoteRequest
     * @example
     * // Get one NoteRequest
     * const noteRequest = await prisma.noteRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteRequestFindFirstArgs>(args?: SelectSubset<T, NoteRequestFindFirstArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NoteRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestFindFirstOrThrowArgs} args - Arguments to find a NoteRequest
     * @example
     * // Get one NoteRequest
     * const noteRequest = await prisma.noteRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NoteRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteRequests
     * const noteRequests = await prisma.noteRequest.findMany()
     * 
     * // Get first 10 NoteRequests
     * const noteRequests = await prisma.noteRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteRequestWithIdOnly = await prisma.noteRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteRequestFindManyArgs>(args?: SelectSubset<T, NoteRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NoteRequest.
     * @param {NoteRequestCreateArgs} args - Arguments to create a NoteRequest.
     * @example
     * // Create one NoteRequest
     * const NoteRequest = await prisma.noteRequest.create({
     *   data: {
     *     // ... data to create a NoteRequest
     *   }
     * })
     * 
     */
    create<T extends NoteRequestCreateArgs>(args: SelectSubset<T, NoteRequestCreateArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NoteRequests.
     * @param {NoteRequestCreateManyArgs} args - Arguments to create many NoteRequests.
     * @example
     * // Create many NoteRequests
     * const noteRequest = await prisma.noteRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteRequestCreateManyArgs>(args?: SelectSubset<T, NoteRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteRequests and returns the data saved in the database.
     * @param {NoteRequestCreateManyAndReturnArgs} args - Arguments to create many NoteRequests.
     * @example
     * // Create many NoteRequests
     * const noteRequest = await prisma.noteRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteRequests and only return the `id`
     * const noteRequestWithIdOnly = await prisma.noteRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NoteRequest.
     * @param {NoteRequestDeleteArgs} args - Arguments to delete one NoteRequest.
     * @example
     * // Delete one NoteRequest
     * const NoteRequest = await prisma.noteRequest.delete({
     *   where: {
     *     // ... filter to delete one NoteRequest
     *   }
     * })
     * 
     */
    delete<T extends NoteRequestDeleteArgs>(args: SelectSubset<T, NoteRequestDeleteArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NoteRequest.
     * @param {NoteRequestUpdateArgs} args - Arguments to update one NoteRequest.
     * @example
     * // Update one NoteRequest
     * const noteRequest = await prisma.noteRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteRequestUpdateArgs>(args: SelectSubset<T, NoteRequestUpdateArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NoteRequests.
     * @param {NoteRequestDeleteManyArgs} args - Arguments to filter NoteRequests to delete.
     * @example
     * // Delete a few NoteRequests
     * const { count } = await prisma.noteRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteRequestDeleteManyArgs>(args?: SelectSubset<T, NoteRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteRequests
     * const noteRequest = await prisma.noteRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteRequestUpdateManyArgs>(args: SelectSubset<T, NoteRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoteRequest.
     * @param {NoteRequestUpsertArgs} args - Arguments to update or create a NoteRequest.
     * @example
     * // Update or create a NoteRequest
     * const noteRequest = await prisma.noteRequest.upsert({
     *   create: {
     *     // ... data to create a NoteRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteRequest we want to update
     *   }
     * })
     */
    upsert<T extends NoteRequestUpsertArgs>(args: SelectSubset<T, NoteRequestUpsertArgs<ExtArgs>>): Prisma__NoteRequestClient<$Result.GetResult<Prisma.$NoteRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NoteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestCountArgs} args - Arguments to filter NoteRequests to count.
     * @example
     * // Count the number of NoteRequests
     * const count = await prisma.noteRequest.count({
     *   where: {
     *     // ... the filter for the NoteRequests we want to count
     *   }
     * })
    **/
    count<T extends NoteRequestCountArgs>(
      args?: Subset<T, NoteRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteRequestAggregateArgs>(args: Subset<T, NoteRequestAggregateArgs>): Prisma.PrismaPromise<GetNoteRequestAggregateType<T>>

    /**
     * Group by NoteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteRequestGroupByArgs['orderBy'] }
        : { orderBy?: NoteRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteRequest model
   */
  readonly fields: NoteRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoteRequest model
   */ 
  interface NoteRequestFieldRefs {
    readonly id: FieldRef<"NoteRequest", 'String'>
    readonly messageId: FieldRef<"NoteRequest", 'String'>
    readonly requestorId: FieldRef<"NoteRequest", 'String'>
    readonly reason: FieldRef<"NoteRequest", 'String'>
    readonly sources: FieldRef<"NoteRequest", 'String[]'>
    readonly timestamp: FieldRef<"NoteRequest", 'DateTime'>
    readonly isActive: FieldRef<"NoteRequest", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NoteRequest findUnique
   */
  export type NoteRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which NoteRequest to fetch.
     */
    where: NoteRequestWhereUniqueInput
  }

  /**
   * NoteRequest findUniqueOrThrow
   */
  export type NoteRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which NoteRequest to fetch.
     */
    where: NoteRequestWhereUniqueInput
  }

  /**
   * NoteRequest findFirst
   */
  export type NoteRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which NoteRequest to fetch.
     */
    where?: NoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRequests to fetch.
     */
    orderBy?: NoteRequestOrderByWithRelationInput | NoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteRequests.
     */
    cursor?: NoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteRequests.
     */
    distinct?: NoteRequestScalarFieldEnum | NoteRequestScalarFieldEnum[]
  }

  /**
   * NoteRequest findFirstOrThrow
   */
  export type NoteRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which NoteRequest to fetch.
     */
    where?: NoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRequests to fetch.
     */
    orderBy?: NoteRequestOrderByWithRelationInput | NoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteRequests.
     */
    cursor?: NoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteRequests.
     */
    distinct?: NoteRequestScalarFieldEnum | NoteRequestScalarFieldEnum[]
  }

  /**
   * NoteRequest findMany
   */
  export type NoteRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which NoteRequests to fetch.
     */
    where?: NoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRequests to fetch.
     */
    orderBy?: NoteRequestOrderByWithRelationInput | NoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteRequests.
     */
    cursor?: NoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRequests.
     */
    skip?: number
    distinct?: NoteRequestScalarFieldEnum | NoteRequestScalarFieldEnum[]
  }

  /**
   * NoteRequest create
   */
  export type NoteRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a NoteRequest.
     */
    data: XOR<NoteRequestCreateInput, NoteRequestUncheckedCreateInput>
  }

  /**
   * NoteRequest createMany
   */
  export type NoteRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteRequests.
     */
    data: NoteRequestCreateManyInput | NoteRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteRequest createManyAndReturn
   */
  export type NoteRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NoteRequests.
     */
    data: NoteRequestCreateManyInput | NoteRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteRequest update
   */
  export type NoteRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a NoteRequest.
     */
    data: XOR<NoteRequestUpdateInput, NoteRequestUncheckedUpdateInput>
    /**
     * Choose, which NoteRequest to update.
     */
    where: NoteRequestWhereUniqueInput
  }

  /**
   * NoteRequest updateMany
   */
  export type NoteRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteRequests.
     */
    data: XOR<NoteRequestUpdateManyMutationInput, NoteRequestUncheckedUpdateManyInput>
    /**
     * Filter which NoteRequests to update
     */
    where?: NoteRequestWhereInput
  }

  /**
   * NoteRequest upsert
   */
  export type NoteRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the NoteRequest to update in case it exists.
     */
    where: NoteRequestWhereUniqueInput
    /**
     * In case the NoteRequest found by the `where` argument doesn't exist, create a new NoteRequest with this data.
     */
    create: XOR<NoteRequestCreateInput, NoteRequestUncheckedCreateInput>
    /**
     * In case the NoteRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteRequestUpdateInput, NoteRequestUncheckedUpdateInput>
  }

  /**
   * NoteRequest delete
   */
  export type NoteRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
    /**
     * Filter which NoteRequest to delete.
     */
    where: NoteRequestWhereUniqueInput
  }

  /**
   * NoteRequest deleteMany
   */
  export type NoteRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteRequests to delete
     */
    where?: NoteRequestWhereInput
  }

  /**
   * NoteRequest without action
   */
  export type NoteRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRequest
     */
    select?: NoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRequestInclude<ExtArgs> | null
  }


  /**
   * Model OpenNote
   */

  export type AggregateOpenNote = {
    _count: OpenNoteCountAggregateOutputType | null
    _avg: OpenNoteAvgAggregateOutputType | null
    _sum: OpenNoteSumAggregateOutputType | null
    _min: OpenNoteMinAggregateOutputType | null
    _max: OpenNoteMaxAggregateOutputType | null
  }

  export type OpenNoteAvgAggregateOutputType = {
    helpfulCount: number | null
    notHelpfulCount: number | null
    totalRatings: number | null
    helpfulnessRatio: number | null
    visibilityScore: number | null
  }

  export type OpenNoteSumAggregateOutputType = {
    helpfulCount: number | null
    notHelpfulCount: number | null
    totalRatings: number | null
    helpfulnessRatio: number | null
    visibilityScore: number | null
  }

  export type OpenNoteMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    authorId: string | null
    content: string | null
    classification: string | null
    status: string | null
    submittedAt: Date | null
    lastStatusAt: Date | null
    helpfulCount: number | null
    notHelpfulCount: number | null
    totalRatings: number | null
    helpfulnessRatio: number | null
    isVisible: boolean | null
    visibilityScore: number | null
  }

  export type OpenNoteMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    authorId: string | null
    content: string | null
    classification: string | null
    status: string | null
    submittedAt: Date | null
    lastStatusAt: Date | null
    helpfulCount: number | null
    notHelpfulCount: number | null
    totalRatings: number | null
    helpfulnessRatio: number | null
    isVisible: boolean | null
    visibilityScore: number | null
  }

  export type OpenNoteCountAggregateOutputType = {
    id: number
    messageId: number
    authorId: number
    content: number
    classification: number
    sources: number
    status: number
    submittedAt: number
    lastStatusAt: number
    helpfulCount: number
    notHelpfulCount: number
    totalRatings: number
    helpfulnessRatio: number
    isVisible: number
    visibilityScore: number
    _all: number
  }


  export type OpenNoteAvgAggregateInputType = {
    helpfulCount?: true
    notHelpfulCount?: true
    totalRatings?: true
    helpfulnessRatio?: true
    visibilityScore?: true
  }

  export type OpenNoteSumAggregateInputType = {
    helpfulCount?: true
    notHelpfulCount?: true
    totalRatings?: true
    helpfulnessRatio?: true
    visibilityScore?: true
  }

  export type OpenNoteMinAggregateInputType = {
    id?: true
    messageId?: true
    authorId?: true
    content?: true
    classification?: true
    status?: true
    submittedAt?: true
    lastStatusAt?: true
    helpfulCount?: true
    notHelpfulCount?: true
    totalRatings?: true
    helpfulnessRatio?: true
    isVisible?: true
    visibilityScore?: true
  }

  export type OpenNoteMaxAggregateInputType = {
    id?: true
    messageId?: true
    authorId?: true
    content?: true
    classification?: true
    status?: true
    submittedAt?: true
    lastStatusAt?: true
    helpfulCount?: true
    notHelpfulCount?: true
    totalRatings?: true
    helpfulnessRatio?: true
    isVisible?: true
    visibilityScore?: true
  }

  export type OpenNoteCountAggregateInputType = {
    id?: true
    messageId?: true
    authorId?: true
    content?: true
    classification?: true
    sources?: true
    status?: true
    submittedAt?: true
    lastStatusAt?: true
    helpfulCount?: true
    notHelpfulCount?: true
    totalRatings?: true
    helpfulnessRatio?: true
    isVisible?: true
    visibilityScore?: true
    _all?: true
  }

  export type OpenNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenNote to aggregate.
     */
    where?: OpenNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenNotes to fetch.
     */
    orderBy?: OpenNoteOrderByWithRelationInput | OpenNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenNotes
    **/
    _count?: true | OpenNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpenNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpenNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenNoteMaxAggregateInputType
  }

  export type GetOpenNoteAggregateType<T extends OpenNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenNote[P]>
      : GetScalarType<T[P], AggregateOpenNote[P]>
  }




  export type OpenNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenNoteWhereInput
    orderBy?: OpenNoteOrderByWithAggregationInput | OpenNoteOrderByWithAggregationInput[]
    by: OpenNoteScalarFieldEnum[] | OpenNoteScalarFieldEnum
    having?: OpenNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenNoteCountAggregateInputType | true
    _avg?: OpenNoteAvgAggregateInputType
    _sum?: OpenNoteSumAggregateInputType
    _min?: OpenNoteMinAggregateInputType
    _max?: OpenNoteMaxAggregateInputType
  }

  export type OpenNoteGroupByOutputType = {
    id: string
    messageId: string
    authorId: string
    content: string
    classification: string
    sources: string[]
    status: string
    submittedAt: Date
    lastStatusAt: Date
    helpfulCount: number
    notHelpfulCount: number
    totalRatings: number
    helpfulnessRatio: number
    isVisible: boolean
    visibilityScore: number
    _count: OpenNoteCountAggregateOutputType | null
    _avg: OpenNoteAvgAggregateOutputType | null
    _sum: OpenNoteSumAggregateOutputType | null
    _min: OpenNoteMinAggregateOutputType | null
    _max: OpenNoteMaxAggregateOutputType | null
  }

  type GetOpenNoteGroupByPayload<T extends OpenNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenNoteGroupByOutputType[P]>
            : GetScalarType<T[P], OpenNoteGroupByOutputType[P]>
        }
      >
    >


  export type OpenNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    authorId?: boolean
    content?: boolean
    classification?: boolean
    sources?: boolean
    status?: boolean
    submittedAt?: boolean
    lastStatusAt?: boolean
    helpfulCount?: boolean
    notHelpfulCount?: boolean
    totalRatings?: boolean
    helpfulnessRatio?: boolean
    isVisible?: boolean
    visibilityScore?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    ratings?: boolean | OpenNote$ratingsArgs<ExtArgs>
    _count?: boolean | OpenNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openNote"]>

  export type OpenNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    authorId?: boolean
    content?: boolean
    classification?: boolean
    sources?: boolean
    status?: boolean
    submittedAt?: boolean
    lastStatusAt?: boolean
    helpfulCount?: boolean
    notHelpfulCount?: boolean
    totalRatings?: boolean
    helpfulnessRatio?: boolean
    isVisible?: boolean
    visibilityScore?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openNote"]>

  export type OpenNoteSelectScalar = {
    id?: boolean
    messageId?: boolean
    authorId?: boolean
    content?: boolean
    classification?: boolean
    sources?: boolean
    status?: boolean
    submittedAt?: boolean
    lastStatusAt?: boolean
    helpfulCount?: boolean
    notHelpfulCount?: boolean
    totalRatings?: boolean
    helpfulnessRatio?: boolean
    isVisible?: boolean
    visibilityScore?: boolean
  }

  export type OpenNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    ratings?: boolean | OpenNote$ratingsArgs<ExtArgs>
    _count?: boolean | OpenNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpenNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OpenNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenNote"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      ratings: Prisma.$NoteRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      authorId: string
      content: string
      classification: string
      sources: string[]
      status: string
      submittedAt: Date
      lastStatusAt: Date
      helpfulCount: number
      notHelpfulCount: number
      totalRatings: number
      helpfulnessRatio: number
      isVisible: boolean
      visibilityScore: number
    }, ExtArgs["result"]["openNote"]>
    composites: {}
  }

  type OpenNoteGetPayload<S extends boolean | null | undefined | OpenNoteDefaultArgs> = $Result.GetResult<Prisma.$OpenNotePayload, S>

  type OpenNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpenNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpenNoteCountAggregateInputType | true
    }

  export interface OpenNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenNote'], meta: { name: 'OpenNote' } }
    /**
     * Find zero or one OpenNote that matches the filter.
     * @param {OpenNoteFindUniqueArgs} args - Arguments to find a OpenNote
     * @example
     * // Get one OpenNote
     * const openNote = await prisma.openNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenNoteFindUniqueArgs>(args: SelectSubset<T, OpenNoteFindUniqueArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OpenNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpenNoteFindUniqueOrThrowArgs} args - Arguments to find a OpenNote
     * @example
     * // Get one OpenNote
     * const openNote = await prisma.openNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OpenNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteFindFirstArgs} args - Arguments to find a OpenNote
     * @example
     * // Get one OpenNote
     * const openNote = await prisma.openNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenNoteFindFirstArgs>(args?: SelectSubset<T, OpenNoteFindFirstArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OpenNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteFindFirstOrThrowArgs} args - Arguments to find a OpenNote
     * @example
     * // Get one OpenNote
     * const openNote = await prisma.openNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OpenNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenNotes
     * const openNotes = await prisma.openNote.findMany()
     * 
     * // Get first 10 OpenNotes
     * const openNotes = await prisma.openNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openNoteWithIdOnly = await prisma.openNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenNoteFindManyArgs>(args?: SelectSubset<T, OpenNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OpenNote.
     * @param {OpenNoteCreateArgs} args - Arguments to create a OpenNote.
     * @example
     * // Create one OpenNote
     * const OpenNote = await prisma.openNote.create({
     *   data: {
     *     // ... data to create a OpenNote
     *   }
     * })
     * 
     */
    create<T extends OpenNoteCreateArgs>(args: SelectSubset<T, OpenNoteCreateArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OpenNotes.
     * @param {OpenNoteCreateManyArgs} args - Arguments to create many OpenNotes.
     * @example
     * // Create many OpenNotes
     * const openNote = await prisma.openNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenNoteCreateManyArgs>(args?: SelectSubset<T, OpenNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenNotes and returns the data saved in the database.
     * @param {OpenNoteCreateManyAndReturnArgs} args - Arguments to create many OpenNotes.
     * @example
     * // Create many OpenNotes
     * const openNote = await prisma.openNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenNotes and only return the `id`
     * const openNoteWithIdOnly = await prisma.openNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OpenNote.
     * @param {OpenNoteDeleteArgs} args - Arguments to delete one OpenNote.
     * @example
     * // Delete one OpenNote
     * const OpenNote = await prisma.openNote.delete({
     *   where: {
     *     // ... filter to delete one OpenNote
     *   }
     * })
     * 
     */
    delete<T extends OpenNoteDeleteArgs>(args: SelectSubset<T, OpenNoteDeleteArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OpenNote.
     * @param {OpenNoteUpdateArgs} args - Arguments to update one OpenNote.
     * @example
     * // Update one OpenNote
     * const openNote = await prisma.openNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenNoteUpdateArgs>(args: SelectSubset<T, OpenNoteUpdateArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OpenNotes.
     * @param {OpenNoteDeleteManyArgs} args - Arguments to filter OpenNotes to delete.
     * @example
     * // Delete a few OpenNotes
     * const { count } = await prisma.openNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenNoteDeleteManyArgs>(args?: SelectSubset<T, OpenNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenNotes
     * const openNote = await prisma.openNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenNoteUpdateManyArgs>(args: SelectSubset<T, OpenNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpenNote.
     * @param {OpenNoteUpsertArgs} args - Arguments to update or create a OpenNote.
     * @example
     * // Update or create a OpenNote
     * const openNote = await prisma.openNote.upsert({
     *   create: {
     *     // ... data to create a OpenNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenNote we want to update
     *   }
     * })
     */
    upsert<T extends OpenNoteUpsertArgs>(args: SelectSubset<T, OpenNoteUpsertArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OpenNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteCountArgs} args - Arguments to filter OpenNotes to count.
     * @example
     * // Count the number of OpenNotes
     * const count = await prisma.openNote.count({
     *   where: {
     *     // ... the filter for the OpenNotes we want to count
     *   }
     * })
    **/
    count<T extends OpenNoteCountArgs>(
      args?: Subset<T, OpenNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenNoteAggregateArgs>(args: Subset<T, OpenNoteAggregateArgs>): Prisma.PrismaPromise<GetOpenNoteAggregateType<T>>

    /**
     * Group by OpenNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenNoteGroupByArgs['orderBy'] }
        : { orderBy?: OpenNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenNote model
   */
  readonly fields: OpenNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ratings<T extends OpenNote$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, OpenNote$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenNote model
   */ 
  interface OpenNoteFieldRefs {
    readonly id: FieldRef<"OpenNote", 'String'>
    readonly messageId: FieldRef<"OpenNote", 'String'>
    readonly authorId: FieldRef<"OpenNote", 'String'>
    readonly content: FieldRef<"OpenNote", 'String'>
    readonly classification: FieldRef<"OpenNote", 'String'>
    readonly sources: FieldRef<"OpenNote", 'String[]'>
    readonly status: FieldRef<"OpenNote", 'String'>
    readonly submittedAt: FieldRef<"OpenNote", 'DateTime'>
    readonly lastStatusAt: FieldRef<"OpenNote", 'DateTime'>
    readonly helpfulCount: FieldRef<"OpenNote", 'Int'>
    readonly notHelpfulCount: FieldRef<"OpenNote", 'Int'>
    readonly totalRatings: FieldRef<"OpenNote", 'Int'>
    readonly helpfulnessRatio: FieldRef<"OpenNote", 'Float'>
    readonly isVisible: FieldRef<"OpenNote", 'Boolean'>
    readonly visibilityScore: FieldRef<"OpenNote", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OpenNote findUnique
   */
  export type OpenNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * Filter, which OpenNote to fetch.
     */
    where: OpenNoteWhereUniqueInput
  }

  /**
   * OpenNote findUniqueOrThrow
   */
  export type OpenNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * Filter, which OpenNote to fetch.
     */
    where: OpenNoteWhereUniqueInput
  }

  /**
   * OpenNote findFirst
   */
  export type OpenNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * Filter, which OpenNote to fetch.
     */
    where?: OpenNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenNotes to fetch.
     */
    orderBy?: OpenNoteOrderByWithRelationInput | OpenNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenNotes.
     */
    cursor?: OpenNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenNotes.
     */
    distinct?: OpenNoteScalarFieldEnum | OpenNoteScalarFieldEnum[]
  }

  /**
   * OpenNote findFirstOrThrow
   */
  export type OpenNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * Filter, which OpenNote to fetch.
     */
    where?: OpenNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenNotes to fetch.
     */
    orderBy?: OpenNoteOrderByWithRelationInput | OpenNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenNotes.
     */
    cursor?: OpenNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenNotes.
     */
    distinct?: OpenNoteScalarFieldEnum | OpenNoteScalarFieldEnum[]
  }

  /**
   * OpenNote findMany
   */
  export type OpenNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * Filter, which OpenNotes to fetch.
     */
    where?: OpenNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenNotes to fetch.
     */
    orderBy?: OpenNoteOrderByWithRelationInput | OpenNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenNotes.
     */
    cursor?: OpenNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenNotes.
     */
    skip?: number
    distinct?: OpenNoteScalarFieldEnum | OpenNoteScalarFieldEnum[]
  }

  /**
   * OpenNote create
   */
  export type OpenNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenNote.
     */
    data: XOR<OpenNoteCreateInput, OpenNoteUncheckedCreateInput>
  }

  /**
   * OpenNote createMany
   */
  export type OpenNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenNotes.
     */
    data: OpenNoteCreateManyInput | OpenNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenNote createManyAndReturn
   */
  export type OpenNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OpenNotes.
     */
    data: OpenNoteCreateManyInput | OpenNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpenNote update
   */
  export type OpenNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenNote.
     */
    data: XOR<OpenNoteUpdateInput, OpenNoteUncheckedUpdateInput>
    /**
     * Choose, which OpenNote to update.
     */
    where: OpenNoteWhereUniqueInput
  }

  /**
   * OpenNote updateMany
   */
  export type OpenNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenNotes.
     */
    data: XOR<OpenNoteUpdateManyMutationInput, OpenNoteUncheckedUpdateManyInput>
    /**
     * Filter which OpenNotes to update
     */
    where?: OpenNoteWhereInput
  }

  /**
   * OpenNote upsert
   */
  export type OpenNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenNote to update in case it exists.
     */
    where: OpenNoteWhereUniqueInput
    /**
     * In case the OpenNote found by the `where` argument doesn't exist, create a new OpenNote with this data.
     */
    create: XOR<OpenNoteCreateInput, OpenNoteUncheckedCreateInput>
    /**
     * In case the OpenNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenNoteUpdateInput, OpenNoteUncheckedUpdateInput>
  }

  /**
   * OpenNote delete
   */
  export type OpenNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
    /**
     * Filter which OpenNote to delete.
     */
    where: OpenNoteWhereUniqueInput
  }

  /**
   * OpenNote deleteMany
   */
  export type OpenNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenNotes to delete
     */
    where?: OpenNoteWhereInput
  }

  /**
   * OpenNote.ratings
   */
  export type OpenNote$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    where?: NoteRatingWhereInput
    orderBy?: NoteRatingOrderByWithRelationInput | NoteRatingOrderByWithRelationInput[]
    cursor?: NoteRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteRatingScalarFieldEnum | NoteRatingScalarFieldEnum[]
  }

  /**
   * OpenNote without action
   */
  export type OpenNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenNote
     */
    select?: OpenNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenNoteInclude<ExtArgs> | null
  }


  /**
   * Model NoteRating
   */

  export type AggregateNoteRating = {
    _count: NoteRatingCountAggregateOutputType | null
    _avg: NoteRatingAvgAggregateOutputType | null
    _sum: NoteRatingSumAggregateOutputType | null
    _min: NoteRatingMinAggregateOutputType | null
    _max: NoteRatingMaxAggregateOutputType | null
  }

  export type NoteRatingAvgAggregateOutputType = {
    weight: number | null
  }

  export type NoteRatingSumAggregateOutputType = {
    weight: number | null
  }

  export type NoteRatingMinAggregateOutputType = {
    id: string | null
    noteId: string | null
    raterId: string | null
    helpful: boolean | null
    reason: string | null
    timestamp: Date | null
    weight: number | null
  }

  export type NoteRatingMaxAggregateOutputType = {
    id: string | null
    noteId: string | null
    raterId: string | null
    helpful: boolean | null
    reason: string | null
    timestamp: Date | null
    weight: number | null
  }

  export type NoteRatingCountAggregateOutputType = {
    id: number
    noteId: number
    raterId: number
    helpful: number
    reason: number
    timestamp: number
    weight: number
    _all: number
  }


  export type NoteRatingAvgAggregateInputType = {
    weight?: true
  }

  export type NoteRatingSumAggregateInputType = {
    weight?: true
  }

  export type NoteRatingMinAggregateInputType = {
    id?: true
    noteId?: true
    raterId?: true
    helpful?: true
    reason?: true
    timestamp?: true
    weight?: true
  }

  export type NoteRatingMaxAggregateInputType = {
    id?: true
    noteId?: true
    raterId?: true
    helpful?: true
    reason?: true
    timestamp?: true
    weight?: true
  }

  export type NoteRatingCountAggregateInputType = {
    id?: true
    noteId?: true
    raterId?: true
    helpful?: true
    reason?: true
    timestamp?: true
    weight?: true
    _all?: true
  }

  export type NoteRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteRating to aggregate.
     */
    where?: NoteRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRatings to fetch.
     */
    orderBy?: NoteRatingOrderByWithRelationInput | NoteRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteRatings
    **/
    _count?: true | NoteRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteRatingMaxAggregateInputType
  }

  export type GetNoteRatingAggregateType<T extends NoteRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteRating[P]>
      : GetScalarType<T[P], AggregateNoteRating[P]>
  }




  export type NoteRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteRatingWhereInput
    orderBy?: NoteRatingOrderByWithAggregationInput | NoteRatingOrderByWithAggregationInput[]
    by: NoteRatingScalarFieldEnum[] | NoteRatingScalarFieldEnum
    having?: NoteRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteRatingCountAggregateInputType | true
    _avg?: NoteRatingAvgAggregateInputType
    _sum?: NoteRatingSumAggregateInputType
    _min?: NoteRatingMinAggregateInputType
    _max?: NoteRatingMaxAggregateInputType
  }

  export type NoteRatingGroupByOutputType = {
    id: string
    noteId: string
    raterId: string
    helpful: boolean
    reason: string | null
    timestamp: Date
    weight: number
    _count: NoteRatingCountAggregateOutputType | null
    _avg: NoteRatingAvgAggregateOutputType | null
    _sum: NoteRatingSumAggregateOutputType | null
    _min: NoteRatingMinAggregateOutputType | null
    _max: NoteRatingMaxAggregateOutputType | null
  }

  type GetNoteRatingGroupByPayload<T extends NoteRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteRatingGroupByOutputType[P]>
            : GetScalarType<T[P], NoteRatingGroupByOutputType[P]>
        }
      >
    >


  export type NoteRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    raterId?: boolean
    helpful?: boolean
    reason?: boolean
    timestamp?: boolean
    weight?: boolean
    note?: boolean | OpenNoteDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteRating"]>

  export type NoteRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    raterId?: boolean
    helpful?: boolean
    reason?: boolean
    timestamp?: boolean
    weight?: boolean
    note?: boolean | OpenNoteDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteRating"]>

  export type NoteRatingSelectScalar = {
    id?: boolean
    noteId?: boolean
    raterId?: boolean
    helpful?: boolean
    reason?: boolean
    timestamp?: boolean
    weight?: boolean
  }

  export type NoteRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | OpenNoteDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | OpenNoteDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NoteRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteRating"
    objects: {
      note: Prisma.$OpenNotePayload<ExtArgs>
      rater: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      noteId: string
      raterId: string
      helpful: boolean
      reason: string | null
      timestamp: Date
      weight: number
    }, ExtArgs["result"]["noteRating"]>
    composites: {}
  }

  type NoteRatingGetPayload<S extends boolean | null | undefined | NoteRatingDefaultArgs> = $Result.GetResult<Prisma.$NoteRatingPayload, S>

  type NoteRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteRatingCountAggregateInputType | true
    }

  export interface NoteRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteRating'], meta: { name: 'NoteRating' } }
    /**
     * Find zero or one NoteRating that matches the filter.
     * @param {NoteRatingFindUniqueArgs} args - Arguments to find a NoteRating
     * @example
     * // Get one NoteRating
     * const noteRating = await prisma.noteRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteRatingFindUniqueArgs>(args: SelectSubset<T, NoteRatingFindUniqueArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NoteRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteRatingFindUniqueOrThrowArgs} args - Arguments to find a NoteRating
     * @example
     * // Get one NoteRating
     * const noteRating = await prisma.noteRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NoteRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingFindFirstArgs} args - Arguments to find a NoteRating
     * @example
     * // Get one NoteRating
     * const noteRating = await prisma.noteRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteRatingFindFirstArgs>(args?: SelectSubset<T, NoteRatingFindFirstArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NoteRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingFindFirstOrThrowArgs} args - Arguments to find a NoteRating
     * @example
     * // Get one NoteRating
     * const noteRating = await prisma.noteRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NoteRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteRatings
     * const noteRatings = await prisma.noteRating.findMany()
     * 
     * // Get first 10 NoteRatings
     * const noteRatings = await prisma.noteRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteRatingWithIdOnly = await prisma.noteRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteRatingFindManyArgs>(args?: SelectSubset<T, NoteRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NoteRating.
     * @param {NoteRatingCreateArgs} args - Arguments to create a NoteRating.
     * @example
     * // Create one NoteRating
     * const NoteRating = await prisma.noteRating.create({
     *   data: {
     *     // ... data to create a NoteRating
     *   }
     * })
     * 
     */
    create<T extends NoteRatingCreateArgs>(args: SelectSubset<T, NoteRatingCreateArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NoteRatings.
     * @param {NoteRatingCreateManyArgs} args - Arguments to create many NoteRatings.
     * @example
     * // Create many NoteRatings
     * const noteRating = await prisma.noteRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteRatingCreateManyArgs>(args?: SelectSubset<T, NoteRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteRatings and returns the data saved in the database.
     * @param {NoteRatingCreateManyAndReturnArgs} args - Arguments to create many NoteRatings.
     * @example
     * // Create many NoteRatings
     * const noteRating = await prisma.noteRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteRatings and only return the `id`
     * const noteRatingWithIdOnly = await prisma.noteRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NoteRating.
     * @param {NoteRatingDeleteArgs} args - Arguments to delete one NoteRating.
     * @example
     * // Delete one NoteRating
     * const NoteRating = await prisma.noteRating.delete({
     *   where: {
     *     // ... filter to delete one NoteRating
     *   }
     * })
     * 
     */
    delete<T extends NoteRatingDeleteArgs>(args: SelectSubset<T, NoteRatingDeleteArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NoteRating.
     * @param {NoteRatingUpdateArgs} args - Arguments to update one NoteRating.
     * @example
     * // Update one NoteRating
     * const noteRating = await prisma.noteRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteRatingUpdateArgs>(args: SelectSubset<T, NoteRatingUpdateArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NoteRatings.
     * @param {NoteRatingDeleteManyArgs} args - Arguments to filter NoteRatings to delete.
     * @example
     * // Delete a few NoteRatings
     * const { count } = await prisma.noteRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteRatingDeleteManyArgs>(args?: SelectSubset<T, NoteRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteRatings
     * const noteRating = await prisma.noteRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteRatingUpdateManyArgs>(args: SelectSubset<T, NoteRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoteRating.
     * @param {NoteRatingUpsertArgs} args - Arguments to update or create a NoteRating.
     * @example
     * // Update or create a NoteRating
     * const noteRating = await prisma.noteRating.upsert({
     *   create: {
     *     // ... data to create a NoteRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteRating we want to update
     *   }
     * })
     */
    upsert<T extends NoteRatingUpsertArgs>(args: SelectSubset<T, NoteRatingUpsertArgs<ExtArgs>>): Prisma__NoteRatingClient<$Result.GetResult<Prisma.$NoteRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NoteRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingCountArgs} args - Arguments to filter NoteRatings to count.
     * @example
     * // Count the number of NoteRatings
     * const count = await prisma.noteRating.count({
     *   where: {
     *     // ... the filter for the NoteRatings we want to count
     *   }
     * })
    **/
    count<T extends NoteRatingCountArgs>(
      args?: Subset<T, NoteRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteRatingAggregateArgs>(args: Subset<T, NoteRatingAggregateArgs>): Prisma.PrismaPromise<GetNoteRatingAggregateType<T>>

    /**
     * Group by NoteRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteRatingGroupByArgs['orderBy'] }
        : { orderBy?: NoteRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteRating model
   */
  readonly fields: NoteRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends OpenNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpenNoteDefaultArgs<ExtArgs>>): Prisma__OpenNoteClient<$Result.GetResult<Prisma.$OpenNotePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoteRating model
   */ 
  interface NoteRatingFieldRefs {
    readonly id: FieldRef<"NoteRating", 'String'>
    readonly noteId: FieldRef<"NoteRating", 'String'>
    readonly raterId: FieldRef<"NoteRating", 'String'>
    readonly helpful: FieldRef<"NoteRating", 'Boolean'>
    readonly reason: FieldRef<"NoteRating", 'String'>
    readonly timestamp: FieldRef<"NoteRating", 'DateTime'>
    readonly weight: FieldRef<"NoteRating", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * NoteRating findUnique
   */
  export type NoteRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * Filter, which NoteRating to fetch.
     */
    where: NoteRatingWhereUniqueInput
  }

  /**
   * NoteRating findUniqueOrThrow
   */
  export type NoteRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * Filter, which NoteRating to fetch.
     */
    where: NoteRatingWhereUniqueInput
  }

  /**
   * NoteRating findFirst
   */
  export type NoteRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * Filter, which NoteRating to fetch.
     */
    where?: NoteRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRatings to fetch.
     */
    orderBy?: NoteRatingOrderByWithRelationInput | NoteRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteRatings.
     */
    cursor?: NoteRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteRatings.
     */
    distinct?: NoteRatingScalarFieldEnum | NoteRatingScalarFieldEnum[]
  }

  /**
   * NoteRating findFirstOrThrow
   */
  export type NoteRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * Filter, which NoteRating to fetch.
     */
    where?: NoteRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRatings to fetch.
     */
    orderBy?: NoteRatingOrderByWithRelationInput | NoteRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteRatings.
     */
    cursor?: NoteRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteRatings.
     */
    distinct?: NoteRatingScalarFieldEnum | NoteRatingScalarFieldEnum[]
  }

  /**
   * NoteRating findMany
   */
  export type NoteRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * Filter, which NoteRatings to fetch.
     */
    where?: NoteRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteRatings to fetch.
     */
    orderBy?: NoteRatingOrderByWithRelationInput | NoteRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteRatings.
     */
    cursor?: NoteRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteRatings.
     */
    skip?: number
    distinct?: NoteRatingScalarFieldEnum | NoteRatingScalarFieldEnum[]
  }

  /**
   * NoteRating create
   */
  export type NoteRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a NoteRating.
     */
    data: XOR<NoteRatingCreateInput, NoteRatingUncheckedCreateInput>
  }

  /**
   * NoteRating createMany
   */
  export type NoteRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteRatings.
     */
    data: NoteRatingCreateManyInput | NoteRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteRating createManyAndReturn
   */
  export type NoteRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NoteRatings.
     */
    data: NoteRatingCreateManyInput | NoteRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteRating update
   */
  export type NoteRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a NoteRating.
     */
    data: XOR<NoteRatingUpdateInput, NoteRatingUncheckedUpdateInput>
    /**
     * Choose, which NoteRating to update.
     */
    where: NoteRatingWhereUniqueInput
  }

  /**
   * NoteRating updateMany
   */
  export type NoteRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteRatings.
     */
    data: XOR<NoteRatingUpdateManyMutationInput, NoteRatingUncheckedUpdateManyInput>
    /**
     * Filter which NoteRatings to update
     */
    where?: NoteRatingWhereInput
  }

  /**
   * NoteRating upsert
   */
  export type NoteRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the NoteRating to update in case it exists.
     */
    where: NoteRatingWhereUniqueInput
    /**
     * In case the NoteRating found by the `where` argument doesn't exist, create a new NoteRating with this data.
     */
    create: XOR<NoteRatingCreateInput, NoteRatingUncheckedCreateInput>
    /**
     * In case the NoteRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteRatingUpdateInput, NoteRatingUncheckedUpdateInput>
  }

  /**
   * NoteRating delete
   */
  export type NoteRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
    /**
     * Filter which NoteRating to delete.
     */
    where: NoteRatingWhereUniqueInput
  }

  /**
   * NoteRating deleteMany
   */
  export type NoteRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteRatings to delete
     */
    where?: NoteRatingWhereInput
  }

  /**
   * NoteRating without action
   */
  export type NoteRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteRating
     */
    select?: NoteRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteRatingInclude<ExtArgs> | null
  }


  /**
   * Model RequestAggregation
   */

  export type AggregateRequestAggregation = {
    _count: RequestAggregationCountAggregateOutputType | null
    _avg: RequestAggregationAvgAggregateOutputType | null
    _sum: RequestAggregationSumAggregateOutputType | null
    _min: RequestAggregationMinAggregateOutputType | null
    _max: RequestAggregationMaxAggregateOutputType | null
  }

  export type RequestAggregationAvgAggregateOutputType = {
    totalRequests: number | null
    uniqueRequestors: number | null
  }

  export type RequestAggregationSumAggregateOutputType = {
    totalRequests: number | null
    uniqueRequestors: number | null
  }

  export type RequestAggregationMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    totalRequests: number | null
    uniqueRequestors: number | null
    firstRequestAt: Date | null
    lastRequestAt: Date | null
    thresholdMet: boolean | null
    thresholdMetAt: Date | null
    contributorsNotified: boolean | null
    notifiedAt: Date | null
  }

  export type RequestAggregationMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    totalRequests: number | null
    uniqueRequestors: number | null
    firstRequestAt: Date | null
    lastRequestAt: Date | null
    thresholdMet: boolean | null
    thresholdMetAt: Date | null
    contributorsNotified: boolean | null
    notifiedAt: Date | null
  }

  export type RequestAggregationCountAggregateOutputType = {
    id: number
    messageId: number
    totalRequests: number
    uniqueRequestors: number
    firstRequestAt: number
    lastRequestAt: number
    thresholdMet: number
    thresholdMetAt: number
    contributorsNotified: number
    notifiedAt: number
    _all: number
  }


  export type RequestAggregationAvgAggregateInputType = {
    totalRequests?: true
    uniqueRequestors?: true
  }

  export type RequestAggregationSumAggregateInputType = {
    totalRequests?: true
    uniqueRequestors?: true
  }

  export type RequestAggregationMinAggregateInputType = {
    id?: true
    messageId?: true
    totalRequests?: true
    uniqueRequestors?: true
    firstRequestAt?: true
    lastRequestAt?: true
    thresholdMet?: true
    thresholdMetAt?: true
    contributorsNotified?: true
    notifiedAt?: true
  }

  export type RequestAggregationMaxAggregateInputType = {
    id?: true
    messageId?: true
    totalRequests?: true
    uniqueRequestors?: true
    firstRequestAt?: true
    lastRequestAt?: true
    thresholdMet?: true
    thresholdMetAt?: true
    contributorsNotified?: true
    notifiedAt?: true
  }

  export type RequestAggregationCountAggregateInputType = {
    id?: true
    messageId?: true
    totalRequests?: true
    uniqueRequestors?: true
    firstRequestAt?: true
    lastRequestAt?: true
    thresholdMet?: true
    thresholdMetAt?: true
    contributorsNotified?: true
    notifiedAt?: true
    _all?: true
  }

  export type RequestAggregationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestAggregation to aggregate.
     */
    where?: RequestAggregationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAggregations to fetch.
     */
    orderBy?: RequestAggregationOrderByWithRelationInput | RequestAggregationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestAggregationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAggregations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAggregations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestAggregations
    **/
    _count?: true | RequestAggregationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestAggregationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestAggregationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestAggregationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestAggregationMaxAggregateInputType
  }

  export type GetRequestAggregationAggregateType<T extends RequestAggregationAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestAggregation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestAggregation[P]>
      : GetScalarType<T[P], AggregateRequestAggregation[P]>
  }




  export type RequestAggregationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestAggregationWhereInput
    orderBy?: RequestAggregationOrderByWithAggregationInput | RequestAggregationOrderByWithAggregationInput[]
    by: RequestAggregationScalarFieldEnum[] | RequestAggregationScalarFieldEnum
    having?: RequestAggregationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestAggregationCountAggregateInputType | true
    _avg?: RequestAggregationAvgAggregateInputType
    _sum?: RequestAggregationSumAggregateInputType
    _min?: RequestAggregationMinAggregateInputType
    _max?: RequestAggregationMaxAggregateInputType
  }

  export type RequestAggregationGroupByOutputType = {
    id: string
    messageId: string
    totalRequests: number
    uniqueRequestors: number
    firstRequestAt: Date | null
    lastRequestAt: Date | null
    thresholdMet: boolean
    thresholdMetAt: Date | null
    contributorsNotified: boolean
    notifiedAt: Date | null
    _count: RequestAggregationCountAggregateOutputType | null
    _avg: RequestAggregationAvgAggregateOutputType | null
    _sum: RequestAggregationSumAggregateOutputType | null
    _min: RequestAggregationMinAggregateOutputType | null
    _max: RequestAggregationMaxAggregateOutputType | null
  }

  type GetRequestAggregationGroupByPayload<T extends RequestAggregationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestAggregationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestAggregationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestAggregationGroupByOutputType[P]>
            : GetScalarType<T[P], RequestAggregationGroupByOutputType[P]>
        }
      >
    >


  export type RequestAggregationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    totalRequests?: boolean
    uniqueRequestors?: boolean
    firstRequestAt?: boolean
    lastRequestAt?: boolean
    thresholdMet?: boolean
    thresholdMetAt?: boolean
    contributorsNotified?: boolean
    notifiedAt?: boolean
  }, ExtArgs["result"]["requestAggregation"]>

  export type RequestAggregationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    totalRequests?: boolean
    uniqueRequestors?: boolean
    firstRequestAt?: boolean
    lastRequestAt?: boolean
    thresholdMet?: boolean
    thresholdMetAt?: boolean
    contributorsNotified?: boolean
    notifiedAt?: boolean
  }, ExtArgs["result"]["requestAggregation"]>

  export type RequestAggregationSelectScalar = {
    id?: boolean
    messageId?: boolean
    totalRequests?: boolean
    uniqueRequestors?: boolean
    firstRequestAt?: boolean
    lastRequestAt?: boolean
    thresholdMet?: boolean
    thresholdMetAt?: boolean
    contributorsNotified?: boolean
    notifiedAt?: boolean
  }


  export type $RequestAggregationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestAggregation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      totalRequests: number
      uniqueRequestors: number
      firstRequestAt: Date | null
      lastRequestAt: Date | null
      thresholdMet: boolean
      thresholdMetAt: Date | null
      contributorsNotified: boolean
      notifiedAt: Date | null
    }, ExtArgs["result"]["requestAggregation"]>
    composites: {}
  }

  type RequestAggregationGetPayload<S extends boolean | null | undefined | RequestAggregationDefaultArgs> = $Result.GetResult<Prisma.$RequestAggregationPayload, S>

  type RequestAggregationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RequestAggregationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RequestAggregationCountAggregateInputType | true
    }

  export interface RequestAggregationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestAggregation'], meta: { name: 'RequestAggregation' } }
    /**
     * Find zero or one RequestAggregation that matches the filter.
     * @param {RequestAggregationFindUniqueArgs} args - Arguments to find a RequestAggregation
     * @example
     * // Get one RequestAggregation
     * const requestAggregation = await prisma.requestAggregation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestAggregationFindUniqueArgs>(args: SelectSubset<T, RequestAggregationFindUniqueArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RequestAggregation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RequestAggregationFindUniqueOrThrowArgs} args - Arguments to find a RequestAggregation
     * @example
     * // Get one RequestAggregation
     * const requestAggregation = await prisma.requestAggregation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestAggregationFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestAggregationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RequestAggregation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationFindFirstArgs} args - Arguments to find a RequestAggregation
     * @example
     * // Get one RequestAggregation
     * const requestAggregation = await prisma.requestAggregation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestAggregationFindFirstArgs>(args?: SelectSubset<T, RequestAggregationFindFirstArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RequestAggregation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationFindFirstOrThrowArgs} args - Arguments to find a RequestAggregation
     * @example
     * // Get one RequestAggregation
     * const requestAggregation = await prisma.requestAggregation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestAggregationFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestAggregationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RequestAggregations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestAggregations
     * const requestAggregations = await prisma.requestAggregation.findMany()
     * 
     * // Get first 10 RequestAggregations
     * const requestAggregations = await prisma.requestAggregation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestAggregationWithIdOnly = await prisma.requestAggregation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestAggregationFindManyArgs>(args?: SelectSubset<T, RequestAggregationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RequestAggregation.
     * @param {RequestAggregationCreateArgs} args - Arguments to create a RequestAggregation.
     * @example
     * // Create one RequestAggregation
     * const RequestAggregation = await prisma.requestAggregation.create({
     *   data: {
     *     // ... data to create a RequestAggregation
     *   }
     * })
     * 
     */
    create<T extends RequestAggregationCreateArgs>(args: SelectSubset<T, RequestAggregationCreateArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RequestAggregations.
     * @param {RequestAggregationCreateManyArgs} args - Arguments to create many RequestAggregations.
     * @example
     * // Create many RequestAggregations
     * const requestAggregation = await prisma.requestAggregation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestAggregationCreateManyArgs>(args?: SelectSubset<T, RequestAggregationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestAggregations and returns the data saved in the database.
     * @param {RequestAggregationCreateManyAndReturnArgs} args - Arguments to create many RequestAggregations.
     * @example
     * // Create many RequestAggregations
     * const requestAggregation = await prisma.requestAggregation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestAggregations and only return the `id`
     * const requestAggregationWithIdOnly = await prisma.requestAggregation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestAggregationCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestAggregationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RequestAggregation.
     * @param {RequestAggregationDeleteArgs} args - Arguments to delete one RequestAggregation.
     * @example
     * // Delete one RequestAggregation
     * const RequestAggregation = await prisma.requestAggregation.delete({
     *   where: {
     *     // ... filter to delete one RequestAggregation
     *   }
     * })
     * 
     */
    delete<T extends RequestAggregationDeleteArgs>(args: SelectSubset<T, RequestAggregationDeleteArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RequestAggregation.
     * @param {RequestAggregationUpdateArgs} args - Arguments to update one RequestAggregation.
     * @example
     * // Update one RequestAggregation
     * const requestAggregation = await prisma.requestAggregation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestAggregationUpdateArgs>(args: SelectSubset<T, RequestAggregationUpdateArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RequestAggregations.
     * @param {RequestAggregationDeleteManyArgs} args - Arguments to filter RequestAggregations to delete.
     * @example
     * // Delete a few RequestAggregations
     * const { count } = await prisma.requestAggregation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestAggregationDeleteManyArgs>(args?: SelectSubset<T, RequestAggregationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestAggregations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestAggregations
     * const requestAggregation = await prisma.requestAggregation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestAggregationUpdateManyArgs>(args: SelectSubset<T, RequestAggregationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestAggregation.
     * @param {RequestAggregationUpsertArgs} args - Arguments to update or create a RequestAggregation.
     * @example
     * // Update or create a RequestAggregation
     * const requestAggregation = await prisma.requestAggregation.upsert({
     *   create: {
     *     // ... data to create a RequestAggregation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestAggregation we want to update
     *   }
     * })
     */
    upsert<T extends RequestAggregationUpsertArgs>(args: SelectSubset<T, RequestAggregationUpsertArgs<ExtArgs>>): Prisma__RequestAggregationClient<$Result.GetResult<Prisma.$RequestAggregationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RequestAggregations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationCountArgs} args - Arguments to filter RequestAggregations to count.
     * @example
     * // Count the number of RequestAggregations
     * const count = await prisma.requestAggregation.count({
     *   where: {
     *     // ... the filter for the RequestAggregations we want to count
     *   }
     * })
    **/
    count<T extends RequestAggregationCountArgs>(
      args?: Subset<T, RequestAggregationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestAggregationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestAggregation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregationAggregateArgs>(args: Subset<T, RequestAggregationAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregationAggregateType<T>>

    /**
     * Group by RequestAggregation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestAggregationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestAggregationGroupByArgs['orderBy'] }
        : { orderBy?: RequestAggregationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestAggregationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestAggregationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestAggregation model
   */
  readonly fields: RequestAggregationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestAggregation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestAggregationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestAggregation model
   */ 
  interface RequestAggregationFieldRefs {
    readonly id: FieldRef<"RequestAggregation", 'String'>
    readonly messageId: FieldRef<"RequestAggregation", 'String'>
    readonly totalRequests: FieldRef<"RequestAggregation", 'Int'>
    readonly uniqueRequestors: FieldRef<"RequestAggregation", 'Int'>
    readonly firstRequestAt: FieldRef<"RequestAggregation", 'DateTime'>
    readonly lastRequestAt: FieldRef<"RequestAggregation", 'DateTime'>
    readonly thresholdMet: FieldRef<"RequestAggregation", 'Boolean'>
    readonly thresholdMetAt: FieldRef<"RequestAggregation", 'DateTime'>
    readonly contributorsNotified: FieldRef<"RequestAggregation", 'Boolean'>
    readonly notifiedAt: FieldRef<"RequestAggregation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestAggregation findUnique
   */
  export type RequestAggregationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * Filter, which RequestAggregation to fetch.
     */
    where: RequestAggregationWhereUniqueInput
  }

  /**
   * RequestAggregation findUniqueOrThrow
   */
  export type RequestAggregationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * Filter, which RequestAggregation to fetch.
     */
    where: RequestAggregationWhereUniqueInput
  }

  /**
   * RequestAggregation findFirst
   */
  export type RequestAggregationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * Filter, which RequestAggregation to fetch.
     */
    where?: RequestAggregationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAggregations to fetch.
     */
    orderBy?: RequestAggregationOrderByWithRelationInput | RequestAggregationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestAggregations.
     */
    cursor?: RequestAggregationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAggregations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAggregations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestAggregations.
     */
    distinct?: RequestAggregationScalarFieldEnum | RequestAggregationScalarFieldEnum[]
  }

  /**
   * RequestAggregation findFirstOrThrow
   */
  export type RequestAggregationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * Filter, which RequestAggregation to fetch.
     */
    where?: RequestAggregationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAggregations to fetch.
     */
    orderBy?: RequestAggregationOrderByWithRelationInput | RequestAggregationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestAggregations.
     */
    cursor?: RequestAggregationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAggregations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAggregations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestAggregations.
     */
    distinct?: RequestAggregationScalarFieldEnum | RequestAggregationScalarFieldEnum[]
  }

  /**
   * RequestAggregation findMany
   */
  export type RequestAggregationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * Filter, which RequestAggregations to fetch.
     */
    where?: RequestAggregationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAggregations to fetch.
     */
    orderBy?: RequestAggregationOrderByWithRelationInput | RequestAggregationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestAggregations.
     */
    cursor?: RequestAggregationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAggregations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAggregations.
     */
    skip?: number
    distinct?: RequestAggregationScalarFieldEnum | RequestAggregationScalarFieldEnum[]
  }

  /**
   * RequestAggregation create
   */
  export type RequestAggregationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * The data needed to create a RequestAggregation.
     */
    data: XOR<RequestAggregationCreateInput, RequestAggregationUncheckedCreateInput>
  }

  /**
   * RequestAggregation createMany
   */
  export type RequestAggregationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestAggregations.
     */
    data: RequestAggregationCreateManyInput | RequestAggregationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestAggregation createManyAndReturn
   */
  export type RequestAggregationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RequestAggregations.
     */
    data: RequestAggregationCreateManyInput | RequestAggregationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestAggregation update
   */
  export type RequestAggregationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * The data needed to update a RequestAggregation.
     */
    data: XOR<RequestAggregationUpdateInput, RequestAggregationUncheckedUpdateInput>
    /**
     * Choose, which RequestAggregation to update.
     */
    where: RequestAggregationWhereUniqueInput
  }

  /**
   * RequestAggregation updateMany
   */
  export type RequestAggregationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestAggregations.
     */
    data: XOR<RequestAggregationUpdateManyMutationInput, RequestAggregationUncheckedUpdateManyInput>
    /**
     * Filter which RequestAggregations to update
     */
    where?: RequestAggregationWhereInput
  }

  /**
   * RequestAggregation upsert
   */
  export type RequestAggregationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * The filter to search for the RequestAggregation to update in case it exists.
     */
    where: RequestAggregationWhereUniqueInput
    /**
     * In case the RequestAggregation found by the `where` argument doesn't exist, create a new RequestAggregation with this data.
     */
    create: XOR<RequestAggregationCreateInput, RequestAggregationUncheckedCreateInput>
    /**
     * In case the RequestAggregation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestAggregationUpdateInput, RequestAggregationUncheckedUpdateInput>
  }

  /**
   * RequestAggregation delete
   */
  export type RequestAggregationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
    /**
     * Filter which RequestAggregation to delete.
     */
    where: RequestAggregationWhereUniqueInput
  }

  /**
   * RequestAggregation deleteMany
   */
  export type RequestAggregationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestAggregations to delete
     */
    where?: RequestAggregationWhereInput
  }

  /**
   * RequestAggregation without action
   */
  export type RequestAggregationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAggregation
     */
    select?: RequestAggregationSelect<ExtArgs> | null
  }


  /**
   * Model RateLimiting
   */

  export type AggregateRateLimiting = {
    _count: RateLimitingCountAggregateOutputType | null
    _avg: RateLimitingAvgAggregateOutputType | null
    _sum: RateLimitingSumAggregateOutputType | null
    _min: RateLimitingMinAggregateOutputType | null
    _max: RateLimitingMaxAggregateOutputType | null
  }

  export type RateLimitingAvgAggregateOutputType = {
    count: number | null
  }

  export type RateLimitingSumAggregateOutputType = {
    count: number | null
  }

  export type RateLimitingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    limitType: string | null
    count: number | null
    resetAt: Date | null
    createdAt: Date | null
  }

  export type RateLimitingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    limitType: string | null
    count: number | null
    resetAt: Date | null
    createdAt: Date | null
  }

  export type RateLimitingCountAggregateOutputType = {
    id: number
    userId: number
    limitType: number
    count: number
    resetAt: number
    createdAt: number
    _all: number
  }


  export type RateLimitingAvgAggregateInputType = {
    count?: true
  }

  export type RateLimitingSumAggregateInputType = {
    count?: true
  }

  export type RateLimitingMinAggregateInputType = {
    id?: true
    userId?: true
    limitType?: true
    count?: true
    resetAt?: true
    createdAt?: true
  }

  export type RateLimitingMaxAggregateInputType = {
    id?: true
    userId?: true
    limitType?: true
    count?: true
    resetAt?: true
    createdAt?: true
  }

  export type RateLimitingCountAggregateInputType = {
    id?: true
    userId?: true
    limitType?: true
    count?: true
    resetAt?: true
    createdAt?: true
    _all?: true
  }

  export type RateLimitingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimiting to aggregate.
     */
    where?: RateLimitingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitings to fetch.
     */
    orderBy?: RateLimitingOrderByWithRelationInput | RateLimitingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateLimitingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateLimitings
    **/
    _count?: true | RateLimitingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateLimitingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateLimitingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateLimitingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateLimitingMaxAggregateInputType
  }

  export type GetRateLimitingAggregateType<T extends RateLimitingAggregateArgs> = {
        [P in keyof T & keyof AggregateRateLimiting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimiting[P]>
      : GetScalarType<T[P], AggregateRateLimiting[P]>
  }




  export type RateLimitingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateLimitingWhereInput
    orderBy?: RateLimitingOrderByWithAggregationInput | RateLimitingOrderByWithAggregationInput[]
    by: RateLimitingScalarFieldEnum[] | RateLimitingScalarFieldEnum
    having?: RateLimitingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateLimitingCountAggregateInputType | true
    _avg?: RateLimitingAvgAggregateInputType
    _sum?: RateLimitingSumAggregateInputType
    _min?: RateLimitingMinAggregateInputType
    _max?: RateLimitingMaxAggregateInputType
  }

  export type RateLimitingGroupByOutputType = {
    id: string
    userId: string
    limitType: string
    count: number
    resetAt: Date
    createdAt: Date
    _count: RateLimitingCountAggregateOutputType | null
    _avg: RateLimitingAvgAggregateOutputType | null
    _sum: RateLimitingSumAggregateOutputType | null
    _min: RateLimitingMinAggregateOutputType | null
    _max: RateLimitingMaxAggregateOutputType | null
  }

  type GetRateLimitingGroupByPayload<T extends RateLimitingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateLimitingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateLimitingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitingGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitingGroupByOutputType[P]>
        }
      >
    >


  export type RateLimitingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limitType?: boolean
    count?: boolean
    resetAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rateLimiting"]>

  export type RateLimitingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    limitType?: boolean
    count?: boolean
    resetAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rateLimiting"]>

  export type RateLimitingSelectScalar = {
    id?: boolean
    userId?: boolean
    limitType?: boolean
    count?: boolean
    resetAt?: boolean
    createdAt?: boolean
  }


  export type $RateLimitingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RateLimiting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      limitType: string
      count: number
      resetAt: Date
      createdAt: Date
    }, ExtArgs["result"]["rateLimiting"]>
    composites: {}
  }

  type RateLimitingGetPayload<S extends boolean | null | undefined | RateLimitingDefaultArgs> = $Result.GetResult<Prisma.$RateLimitingPayload, S>

  type RateLimitingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RateLimitingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RateLimitingCountAggregateInputType | true
    }

  export interface RateLimitingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RateLimiting'], meta: { name: 'RateLimiting' } }
    /**
     * Find zero or one RateLimiting that matches the filter.
     * @param {RateLimitingFindUniqueArgs} args - Arguments to find a RateLimiting
     * @example
     * // Get one RateLimiting
     * const rateLimiting = await prisma.rateLimiting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitingFindUniqueArgs>(args: SelectSubset<T, RateLimitingFindUniqueArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RateLimiting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RateLimitingFindUniqueOrThrowArgs} args - Arguments to find a RateLimiting
     * @example
     * // Get one RateLimiting
     * const rateLimiting = await prisma.rateLimiting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitingFindUniqueOrThrowArgs>(args: SelectSubset<T, RateLimitingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RateLimiting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingFindFirstArgs} args - Arguments to find a RateLimiting
     * @example
     * // Get one RateLimiting
     * const rateLimiting = await prisma.rateLimiting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitingFindFirstArgs>(args?: SelectSubset<T, RateLimitingFindFirstArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RateLimiting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingFindFirstOrThrowArgs} args - Arguments to find a RateLimiting
     * @example
     * // Get one RateLimiting
     * const rateLimiting = await prisma.rateLimiting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitingFindFirstOrThrowArgs>(args?: SelectSubset<T, RateLimitingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RateLimitings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimitings
     * const rateLimitings = await prisma.rateLimiting.findMany()
     * 
     * // Get first 10 RateLimitings
     * const rateLimitings = await prisma.rateLimiting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateLimitingWithIdOnly = await prisma.rateLimiting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RateLimitingFindManyArgs>(args?: SelectSubset<T, RateLimitingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RateLimiting.
     * @param {RateLimitingCreateArgs} args - Arguments to create a RateLimiting.
     * @example
     * // Create one RateLimiting
     * const RateLimiting = await prisma.rateLimiting.create({
     *   data: {
     *     // ... data to create a RateLimiting
     *   }
     * })
     * 
     */
    create<T extends RateLimitingCreateArgs>(args: SelectSubset<T, RateLimitingCreateArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RateLimitings.
     * @param {RateLimitingCreateManyArgs} args - Arguments to create many RateLimitings.
     * @example
     * // Create many RateLimitings
     * const rateLimiting = await prisma.rateLimiting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RateLimitingCreateManyArgs>(args?: SelectSubset<T, RateLimitingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RateLimitings and returns the data saved in the database.
     * @param {RateLimitingCreateManyAndReturnArgs} args - Arguments to create many RateLimitings.
     * @example
     * // Create many RateLimitings
     * const rateLimiting = await prisma.rateLimiting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RateLimitings and only return the `id`
     * const rateLimitingWithIdOnly = await prisma.rateLimiting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RateLimitingCreateManyAndReturnArgs>(args?: SelectSubset<T, RateLimitingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RateLimiting.
     * @param {RateLimitingDeleteArgs} args - Arguments to delete one RateLimiting.
     * @example
     * // Delete one RateLimiting
     * const RateLimiting = await prisma.rateLimiting.delete({
     *   where: {
     *     // ... filter to delete one RateLimiting
     *   }
     * })
     * 
     */
    delete<T extends RateLimitingDeleteArgs>(args: SelectSubset<T, RateLimitingDeleteArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RateLimiting.
     * @param {RateLimitingUpdateArgs} args - Arguments to update one RateLimiting.
     * @example
     * // Update one RateLimiting
     * const rateLimiting = await prisma.rateLimiting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RateLimitingUpdateArgs>(args: SelectSubset<T, RateLimitingUpdateArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RateLimitings.
     * @param {RateLimitingDeleteManyArgs} args - Arguments to filter RateLimitings to delete.
     * @example
     * // Delete a few RateLimitings
     * const { count } = await prisma.rateLimiting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RateLimitingDeleteManyArgs>(args?: SelectSubset<T, RateLimitingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimitings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimitings
     * const rateLimiting = await prisma.rateLimiting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RateLimitingUpdateManyArgs>(args: SelectSubset<T, RateLimitingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RateLimiting.
     * @param {RateLimitingUpsertArgs} args - Arguments to update or create a RateLimiting.
     * @example
     * // Update or create a RateLimiting
     * const rateLimiting = await prisma.rateLimiting.upsert({
     *   create: {
     *     // ... data to create a RateLimiting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimiting we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitingUpsertArgs>(args: SelectSubset<T, RateLimitingUpsertArgs<ExtArgs>>): Prisma__RateLimitingClient<$Result.GetResult<Prisma.$RateLimitingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RateLimitings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingCountArgs} args - Arguments to filter RateLimitings to count.
     * @example
     * // Count the number of RateLimitings
     * const count = await prisma.rateLimiting.count({
     *   where: {
     *     // ... the filter for the RateLimitings we want to count
     *   }
     * })
    **/
    count<T extends RateLimitingCountArgs>(
      args?: Subset<T, RateLimitingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateLimiting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateLimitingAggregateArgs>(args: Subset<T, RateLimitingAggregateArgs>): Prisma.PrismaPromise<GetRateLimitingAggregateType<T>>

    /**
     * Group by RateLimiting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateLimitingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitingGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateLimitingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateLimitingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RateLimiting model
   */
  readonly fields: RateLimitingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimiting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RateLimiting model
   */ 
  interface RateLimitingFieldRefs {
    readonly id: FieldRef<"RateLimiting", 'String'>
    readonly userId: FieldRef<"RateLimiting", 'String'>
    readonly limitType: FieldRef<"RateLimiting", 'String'>
    readonly count: FieldRef<"RateLimiting", 'Int'>
    readonly resetAt: FieldRef<"RateLimiting", 'DateTime'>
    readonly createdAt: FieldRef<"RateLimiting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RateLimiting findUnique
   */
  export type RateLimitingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * Filter, which RateLimiting to fetch.
     */
    where: RateLimitingWhereUniqueInput
  }

  /**
   * RateLimiting findUniqueOrThrow
   */
  export type RateLimitingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * Filter, which RateLimiting to fetch.
     */
    where: RateLimitingWhereUniqueInput
  }

  /**
   * RateLimiting findFirst
   */
  export type RateLimitingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * Filter, which RateLimiting to fetch.
     */
    where?: RateLimitingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitings to fetch.
     */
    orderBy?: RateLimitingOrderByWithRelationInput | RateLimitingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimitings.
     */
    cursor?: RateLimitingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimitings.
     */
    distinct?: RateLimitingScalarFieldEnum | RateLimitingScalarFieldEnum[]
  }

  /**
   * RateLimiting findFirstOrThrow
   */
  export type RateLimitingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * Filter, which RateLimiting to fetch.
     */
    where?: RateLimitingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitings to fetch.
     */
    orderBy?: RateLimitingOrderByWithRelationInput | RateLimitingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimitings.
     */
    cursor?: RateLimitingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimitings.
     */
    distinct?: RateLimitingScalarFieldEnum | RateLimitingScalarFieldEnum[]
  }

  /**
   * RateLimiting findMany
   */
  export type RateLimitingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * Filter, which RateLimitings to fetch.
     */
    where?: RateLimitingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitings to fetch.
     */
    orderBy?: RateLimitingOrderByWithRelationInput | RateLimitingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateLimitings.
     */
    cursor?: RateLimitingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitings.
     */
    skip?: number
    distinct?: RateLimitingScalarFieldEnum | RateLimitingScalarFieldEnum[]
  }

  /**
   * RateLimiting create
   */
  export type RateLimitingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * The data needed to create a RateLimiting.
     */
    data: XOR<RateLimitingCreateInput, RateLimitingUncheckedCreateInput>
  }

  /**
   * RateLimiting createMany
   */
  export type RateLimitingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RateLimitings.
     */
    data: RateLimitingCreateManyInput | RateLimitingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimiting createManyAndReturn
   */
  export type RateLimitingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RateLimitings.
     */
    data: RateLimitingCreateManyInput | RateLimitingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimiting update
   */
  export type RateLimitingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * The data needed to update a RateLimiting.
     */
    data: XOR<RateLimitingUpdateInput, RateLimitingUncheckedUpdateInput>
    /**
     * Choose, which RateLimiting to update.
     */
    where: RateLimitingWhereUniqueInput
  }

  /**
   * RateLimiting updateMany
   */
  export type RateLimitingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RateLimitings.
     */
    data: XOR<RateLimitingUpdateManyMutationInput, RateLimitingUncheckedUpdateManyInput>
    /**
     * Filter which RateLimitings to update
     */
    where?: RateLimitingWhereInput
  }

  /**
   * RateLimiting upsert
   */
  export type RateLimitingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * The filter to search for the RateLimiting to update in case it exists.
     */
    where: RateLimitingWhereUniqueInput
    /**
     * In case the RateLimiting found by the `where` argument doesn't exist, create a new RateLimiting with this data.
     */
    create: XOR<RateLimitingCreateInput, RateLimitingUncheckedCreateInput>
    /**
     * In case the RateLimiting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitingUpdateInput, RateLimitingUncheckedUpdateInput>
  }

  /**
   * RateLimiting delete
   */
  export type RateLimitingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
    /**
     * Filter which RateLimiting to delete.
     */
    where: RateLimitingWhereUniqueInput
  }

  /**
   * RateLimiting deleteMany
   */
  export type RateLimitingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimitings to delete
     */
    where?: RateLimitingWhereInput
  }

  /**
   * RateLimiting without action
   */
  export type RateLimitingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimiting
     */
    select?: RateLimitingSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    serverId: string | null
    adminId: string | null
    action: string | null
    target: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    serverId: string | null
    adminId: string | null
    action: string | null
    target: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    serverId: number
    adminId: number
    action: number
    target: number
    details: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    serverId?: true
    adminId?: true
    action?: true
    target?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    serverId?: true
    adminId?: true
    action?: true
    target?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    serverId?: true
    adminId?: true
    action?: true
    target?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    serverId: string
    adminId: string
    action: string
    target: string | null
    details: JsonValue | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serverId?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    details?: boolean
    timestamp?: boolean
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serverId?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    details?: boolean
    timestamp?: boolean
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    serverId?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | ServerDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      server: Prisma.$ServerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serverId: string
      adminId: string
      action: string
      target: string | null
      details: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    server<T extends ServerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServerDefaultArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly serverId: FieldRef<"AuditLog", 'String'>
    readonly adminId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly target: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ModerationQueue
   */

  export type AggregateModerationQueue = {
    _count: ModerationQueueCountAggregateOutputType | null
    _min: ModerationQueueMinAggregateOutputType | null
    _max: ModerationQueueMaxAggregateOutputType | null
  }

  export type ModerationQueueMinAggregateOutputType = {
    id: string | null
    serverId: string | null
    itemType: string | null
    itemId: string | null
    flagType: string | null
    flaggedBy: string | null
    reason: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    actionTaken: string | null
    createdAt: Date | null
  }

  export type ModerationQueueMaxAggregateOutputType = {
    id: string | null
    serverId: string | null
    itemType: string | null
    itemId: string | null
    flagType: string | null
    flaggedBy: string | null
    reason: string | null
    status: string | null
    reviewedBy: string | null
    reviewedAt: Date | null
    actionTaken: string | null
    createdAt: Date | null
  }

  export type ModerationQueueCountAggregateOutputType = {
    id: number
    serverId: number
    itemType: number
    itemId: number
    flagType: number
    flaggedBy: number
    reason: number
    status: number
    reviewedBy: number
    reviewedAt: number
    actionTaken: number
    createdAt: number
    _all: number
  }


  export type ModerationQueueMinAggregateInputType = {
    id?: true
    serverId?: true
    itemType?: true
    itemId?: true
    flagType?: true
    flaggedBy?: true
    reason?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    actionTaken?: true
    createdAt?: true
  }

  export type ModerationQueueMaxAggregateInputType = {
    id?: true
    serverId?: true
    itemType?: true
    itemId?: true
    flagType?: true
    flaggedBy?: true
    reason?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    actionTaken?: true
    createdAt?: true
  }

  export type ModerationQueueCountAggregateInputType = {
    id?: true
    serverId?: true
    itemType?: true
    itemId?: true
    flagType?: true
    flaggedBy?: true
    reason?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    actionTaken?: true
    createdAt?: true
    _all?: true
  }

  export type ModerationQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationQueue to aggregate.
     */
    where?: ModerationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationQueues to fetch.
     */
    orderBy?: ModerationQueueOrderByWithRelationInput | ModerationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationQueues
    **/
    _count?: true | ModerationQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationQueueMaxAggregateInputType
  }

  export type GetModerationQueueAggregateType<T extends ModerationQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationQueue[P]>
      : GetScalarType<T[P], AggregateModerationQueue[P]>
  }




  export type ModerationQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationQueueWhereInput
    orderBy?: ModerationQueueOrderByWithAggregationInput | ModerationQueueOrderByWithAggregationInput[]
    by: ModerationQueueScalarFieldEnum[] | ModerationQueueScalarFieldEnum
    having?: ModerationQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationQueueCountAggregateInputType | true
    _min?: ModerationQueueMinAggregateInputType
    _max?: ModerationQueueMaxAggregateInputType
  }

  export type ModerationQueueGroupByOutputType = {
    id: string
    serverId: string
    itemType: string
    itemId: string
    flagType: string
    flaggedBy: string
    reason: string | null
    status: string
    reviewedBy: string | null
    reviewedAt: Date | null
    actionTaken: string | null
    createdAt: Date
    _count: ModerationQueueCountAggregateOutputType | null
    _min: ModerationQueueMinAggregateOutputType | null
    _max: ModerationQueueMaxAggregateOutputType | null
  }

  type GetModerationQueueGroupByPayload<T extends ModerationQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationQueueGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationQueueGroupByOutputType[P]>
        }
      >
    >


  export type ModerationQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serverId?: boolean
    itemType?: boolean
    itemId?: boolean
    flagType?: boolean
    flaggedBy?: boolean
    reason?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["moderationQueue"]>

  export type ModerationQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serverId?: boolean
    itemType?: boolean
    itemId?: boolean
    flagType?: boolean
    flaggedBy?: boolean
    reason?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["moderationQueue"]>

  export type ModerationQueueSelectScalar = {
    id?: boolean
    serverId?: boolean
    itemType?: boolean
    itemId?: boolean
    flagType?: boolean
    flaggedBy?: boolean
    reason?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }


  export type $ModerationQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serverId: string
      itemType: string
      itemId: string
      flagType: string
      flaggedBy: string
      reason: string | null
      status: string
      reviewedBy: string | null
      reviewedAt: Date | null
      actionTaken: string | null
      createdAt: Date
    }, ExtArgs["result"]["moderationQueue"]>
    composites: {}
  }

  type ModerationQueueGetPayload<S extends boolean | null | undefined | ModerationQueueDefaultArgs> = $Result.GetResult<Prisma.$ModerationQueuePayload, S>

  type ModerationQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationQueueCountAggregateInputType | true
    }

  export interface ModerationQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationQueue'], meta: { name: 'ModerationQueue' } }
    /**
     * Find zero or one ModerationQueue that matches the filter.
     * @param {ModerationQueueFindUniqueArgs} args - Arguments to find a ModerationQueue
     * @example
     * // Get one ModerationQueue
     * const moderationQueue = await prisma.moderationQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModerationQueueFindUniqueArgs>(args: SelectSubset<T, ModerationQueueFindUniqueArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModerationQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModerationQueueFindUniqueOrThrowArgs} args - Arguments to find a ModerationQueue
     * @example
     * // Get one ModerationQueue
     * const moderationQueue = await prisma.moderationQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModerationQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, ModerationQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModerationQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueFindFirstArgs} args - Arguments to find a ModerationQueue
     * @example
     * // Get one ModerationQueue
     * const moderationQueue = await prisma.moderationQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModerationQueueFindFirstArgs>(args?: SelectSubset<T, ModerationQueueFindFirstArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModerationQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueFindFirstOrThrowArgs} args - Arguments to find a ModerationQueue
     * @example
     * // Get one ModerationQueue
     * const moderationQueue = await prisma.moderationQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModerationQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, ModerationQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModerationQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationQueues
     * const moderationQueues = await prisma.moderationQueue.findMany()
     * 
     * // Get first 10 ModerationQueues
     * const moderationQueues = await prisma.moderationQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationQueueWithIdOnly = await prisma.moderationQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModerationQueueFindManyArgs>(args?: SelectSubset<T, ModerationQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModerationQueue.
     * @param {ModerationQueueCreateArgs} args - Arguments to create a ModerationQueue.
     * @example
     * // Create one ModerationQueue
     * const ModerationQueue = await prisma.moderationQueue.create({
     *   data: {
     *     // ... data to create a ModerationQueue
     *   }
     * })
     * 
     */
    create<T extends ModerationQueueCreateArgs>(args: SelectSubset<T, ModerationQueueCreateArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModerationQueues.
     * @param {ModerationQueueCreateManyArgs} args - Arguments to create many ModerationQueues.
     * @example
     * // Create many ModerationQueues
     * const moderationQueue = await prisma.moderationQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModerationQueueCreateManyArgs>(args?: SelectSubset<T, ModerationQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModerationQueues and returns the data saved in the database.
     * @param {ModerationQueueCreateManyAndReturnArgs} args - Arguments to create many ModerationQueues.
     * @example
     * // Create many ModerationQueues
     * const moderationQueue = await prisma.moderationQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModerationQueues and only return the `id`
     * const moderationQueueWithIdOnly = await prisma.moderationQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModerationQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, ModerationQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModerationQueue.
     * @param {ModerationQueueDeleteArgs} args - Arguments to delete one ModerationQueue.
     * @example
     * // Delete one ModerationQueue
     * const ModerationQueue = await prisma.moderationQueue.delete({
     *   where: {
     *     // ... filter to delete one ModerationQueue
     *   }
     * })
     * 
     */
    delete<T extends ModerationQueueDeleteArgs>(args: SelectSubset<T, ModerationQueueDeleteArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModerationQueue.
     * @param {ModerationQueueUpdateArgs} args - Arguments to update one ModerationQueue.
     * @example
     * // Update one ModerationQueue
     * const moderationQueue = await prisma.moderationQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModerationQueueUpdateArgs>(args: SelectSubset<T, ModerationQueueUpdateArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModerationQueues.
     * @param {ModerationQueueDeleteManyArgs} args - Arguments to filter ModerationQueues to delete.
     * @example
     * // Delete a few ModerationQueues
     * const { count } = await prisma.moderationQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModerationQueueDeleteManyArgs>(args?: SelectSubset<T, ModerationQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationQueues
     * const moderationQueue = await prisma.moderationQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModerationQueueUpdateManyArgs>(args: SelectSubset<T, ModerationQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationQueue.
     * @param {ModerationQueueUpsertArgs} args - Arguments to update or create a ModerationQueue.
     * @example
     * // Update or create a ModerationQueue
     * const moderationQueue = await prisma.moderationQueue.upsert({
     *   create: {
     *     // ... data to create a ModerationQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationQueue we want to update
     *   }
     * })
     */
    upsert<T extends ModerationQueueUpsertArgs>(args: SelectSubset<T, ModerationQueueUpsertArgs<ExtArgs>>): Prisma__ModerationQueueClient<$Result.GetResult<Prisma.$ModerationQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModerationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueCountArgs} args - Arguments to filter ModerationQueues to count.
     * @example
     * // Count the number of ModerationQueues
     * const count = await prisma.moderationQueue.count({
     *   where: {
     *     // ... the filter for the ModerationQueues we want to count
     *   }
     * })
    **/
    count<T extends ModerationQueueCountArgs>(
      args?: Subset<T, ModerationQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationQueueAggregateArgs>(args: Subset<T, ModerationQueueAggregateArgs>): Prisma.PrismaPromise<GetModerationQueueAggregateType<T>>

    /**
     * Group by ModerationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationQueueGroupByArgs['orderBy'] }
        : { orderBy?: ModerationQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationQueue model
   */
  readonly fields: ModerationQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModerationQueue model
   */ 
  interface ModerationQueueFieldRefs {
    readonly id: FieldRef<"ModerationQueue", 'String'>
    readonly serverId: FieldRef<"ModerationQueue", 'String'>
    readonly itemType: FieldRef<"ModerationQueue", 'String'>
    readonly itemId: FieldRef<"ModerationQueue", 'String'>
    readonly flagType: FieldRef<"ModerationQueue", 'String'>
    readonly flaggedBy: FieldRef<"ModerationQueue", 'String'>
    readonly reason: FieldRef<"ModerationQueue", 'String'>
    readonly status: FieldRef<"ModerationQueue", 'String'>
    readonly reviewedBy: FieldRef<"ModerationQueue", 'String'>
    readonly reviewedAt: FieldRef<"ModerationQueue", 'DateTime'>
    readonly actionTaken: FieldRef<"ModerationQueue", 'String'>
    readonly createdAt: FieldRef<"ModerationQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModerationQueue findUnique
   */
  export type ModerationQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * Filter, which ModerationQueue to fetch.
     */
    where: ModerationQueueWhereUniqueInput
  }

  /**
   * ModerationQueue findUniqueOrThrow
   */
  export type ModerationQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * Filter, which ModerationQueue to fetch.
     */
    where: ModerationQueueWhereUniqueInput
  }

  /**
   * ModerationQueue findFirst
   */
  export type ModerationQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * Filter, which ModerationQueue to fetch.
     */
    where?: ModerationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationQueues to fetch.
     */
    orderBy?: ModerationQueueOrderByWithRelationInput | ModerationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationQueues.
     */
    cursor?: ModerationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationQueues.
     */
    distinct?: ModerationQueueScalarFieldEnum | ModerationQueueScalarFieldEnum[]
  }

  /**
   * ModerationQueue findFirstOrThrow
   */
  export type ModerationQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * Filter, which ModerationQueue to fetch.
     */
    where?: ModerationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationQueues to fetch.
     */
    orderBy?: ModerationQueueOrderByWithRelationInput | ModerationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationQueues.
     */
    cursor?: ModerationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationQueues.
     */
    distinct?: ModerationQueueScalarFieldEnum | ModerationQueueScalarFieldEnum[]
  }

  /**
   * ModerationQueue findMany
   */
  export type ModerationQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * Filter, which ModerationQueues to fetch.
     */
    where?: ModerationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationQueues to fetch.
     */
    orderBy?: ModerationQueueOrderByWithRelationInput | ModerationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationQueues.
     */
    cursor?: ModerationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationQueues.
     */
    skip?: number
    distinct?: ModerationQueueScalarFieldEnum | ModerationQueueScalarFieldEnum[]
  }

  /**
   * ModerationQueue create
   */
  export type ModerationQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationQueue.
     */
    data: XOR<ModerationQueueCreateInput, ModerationQueueUncheckedCreateInput>
  }

  /**
   * ModerationQueue createMany
   */
  export type ModerationQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationQueues.
     */
    data: ModerationQueueCreateManyInput | ModerationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModerationQueue createManyAndReturn
   */
  export type ModerationQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModerationQueues.
     */
    data: ModerationQueueCreateManyInput | ModerationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModerationQueue update
   */
  export type ModerationQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationQueue.
     */
    data: XOR<ModerationQueueUpdateInput, ModerationQueueUncheckedUpdateInput>
    /**
     * Choose, which ModerationQueue to update.
     */
    where: ModerationQueueWhereUniqueInput
  }

  /**
   * ModerationQueue updateMany
   */
  export type ModerationQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationQueues.
     */
    data: XOR<ModerationQueueUpdateManyMutationInput, ModerationQueueUncheckedUpdateManyInput>
    /**
     * Filter which ModerationQueues to update
     */
    where?: ModerationQueueWhereInput
  }

  /**
   * ModerationQueue upsert
   */
  export type ModerationQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationQueue to update in case it exists.
     */
    where: ModerationQueueWhereUniqueInput
    /**
     * In case the ModerationQueue found by the `where` argument doesn't exist, create a new ModerationQueue with this data.
     */
    create: XOR<ModerationQueueCreateInput, ModerationQueueUncheckedCreateInput>
    /**
     * In case the ModerationQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationQueueUpdateInput, ModerationQueueUncheckedUpdateInput>
  }

  /**
   * ModerationQueue delete
   */
  export type ModerationQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
    /**
     * Filter which ModerationQueue to delete.
     */
    where: ModerationQueueWhereUniqueInput
  }

  /**
   * ModerationQueue deleteMany
   */
  export type ModerationQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationQueues to delete
     */
    where?: ModerationQueueWhereInput
  }

  /**
   * ModerationQueue without action
   */
  export type ModerationQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationQueue
     */
    select?: ModerationQueueSelect<ExtArgs> | null
  }


  /**
   * Model NotificationQueue
   */

  export type AggregateNotificationQueue = {
    _count: NotificationQueueCountAggregateOutputType | null
    _avg: NotificationQueueAvgAggregateOutputType | null
    _sum: NotificationQueueSumAggregateOutputType | null
    _min: NotificationQueueMinAggregateOutputType | null
    _max: NotificationQueueMaxAggregateOutputType | null
  }

  export type NotificationQueueAvgAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type NotificationQueueSumAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type NotificationQueueMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    priority: number | null
    status: string | null
    attempts: number | null
    maxAttempts: number | null
    scheduledFor: Date | null
    createdAt: Date | null
    lastAttemptAt: Date | null
    batchKey: string | null
    batchedAt: Date | null
  }

  export type NotificationQueueMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    priority: number | null
    status: string | null
    attempts: number | null
    maxAttempts: number | null
    scheduledFor: Date | null
    createdAt: Date | null
    lastAttemptAt: Date | null
    batchKey: string | null
    batchedAt: Date | null
  }

  export type NotificationQueueCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    priority: number
    data: number
    status: number
    attempts: number
    maxAttempts: number
    scheduledFor: number
    createdAt: number
    lastAttemptAt: number
    batchKey: number
    batchedAt: number
    _all: number
  }


  export type NotificationQueueAvgAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type NotificationQueueSumAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type NotificationQueueMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    scheduledFor?: true
    createdAt?: true
    lastAttemptAt?: true
    batchKey?: true
    batchedAt?: true
  }

  export type NotificationQueueMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    scheduledFor?: true
    createdAt?: true
    lastAttemptAt?: true
    batchKey?: true
    batchedAt?: true
  }

  export type NotificationQueueCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    data?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    scheduledFor?: true
    createdAt?: true
    lastAttemptAt?: true
    batchKey?: true
    batchedAt?: true
    _all?: true
  }

  export type NotificationQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationQueue to aggregate.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationQueues
    **/
    _count?: true | NotificationQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationQueueMaxAggregateInputType
  }

  export type GetNotificationQueueAggregateType<T extends NotificationQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationQueue[P]>
      : GetScalarType<T[P], AggregateNotificationQueue[P]>
  }




  export type NotificationQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationQueueWhereInput
    orderBy?: NotificationQueueOrderByWithAggregationInput | NotificationQueueOrderByWithAggregationInput[]
    by: NotificationQueueScalarFieldEnum[] | NotificationQueueScalarFieldEnum
    having?: NotificationQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationQueueCountAggregateInputType | true
    _avg?: NotificationQueueAvgAggregateInputType
    _sum?: NotificationQueueSumAggregateInputType
    _min?: NotificationQueueMinAggregateInputType
    _max?: NotificationQueueMaxAggregateInputType
  }

  export type NotificationQueueGroupByOutputType = {
    id: string
    userId: string
    type: string
    priority: number
    data: JsonValue
    status: string
    attempts: number
    maxAttempts: number
    scheduledFor: Date | null
    createdAt: Date
    lastAttemptAt: Date | null
    batchKey: string | null
    batchedAt: Date | null
    _count: NotificationQueueCountAggregateOutputType | null
    _avg: NotificationQueueAvgAggregateOutputType | null
    _sum: NotificationQueueSumAggregateOutputType | null
    _min: NotificationQueueMinAggregateOutputType | null
    _max: NotificationQueueMaxAggregateOutputType | null
  }

  type GetNotificationQueueGroupByPayload<T extends NotificationQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
        }
      >
    >


  export type NotificationQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    data?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
    lastAttemptAt?: boolean
    batchKey?: boolean
    batchedAt?: boolean
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    data?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
    lastAttemptAt?: boolean
    batchKey?: boolean
    batchedAt?: boolean
  }, ExtArgs["result"]["notificationQueue"]>

  export type NotificationQueueSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    data?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
    lastAttemptAt?: boolean
    batchKey?: boolean
    batchedAt?: boolean
  }


  export type $NotificationQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      priority: number
      data: Prisma.JsonValue
      status: string
      attempts: number
      maxAttempts: number
      scheduledFor: Date | null
      createdAt: Date
      lastAttemptAt: Date | null
      batchKey: string | null
      batchedAt: Date | null
    }, ExtArgs["result"]["notificationQueue"]>
    composites: {}
  }

  type NotificationQueueGetPayload<S extends boolean | null | undefined | NotificationQueueDefaultArgs> = $Result.GetResult<Prisma.$NotificationQueuePayload, S>

  type NotificationQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationQueueCountAggregateInputType | true
    }

  export interface NotificationQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationQueue'], meta: { name: 'NotificationQueue' } }
    /**
     * Find zero or one NotificationQueue that matches the filter.
     * @param {NotificationQueueFindUniqueArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationQueueFindUniqueArgs>(args: SelectSubset<T, NotificationQueueFindUniqueArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationQueueFindUniqueOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationQueueFindFirstArgs>(args?: SelectSubset<T, NotificationQueueFindFirstArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany()
     * 
     * // Get first 10 NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationQueueFindManyArgs>(args?: SelectSubset<T, NotificationQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationQueue.
     * @param {NotificationQueueCreateArgs} args - Arguments to create a NotificationQueue.
     * @example
     * // Create one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.create({
     *   data: {
     *     // ... data to create a NotificationQueue
     *   }
     * })
     * 
     */
    create<T extends NotificationQueueCreateArgs>(args: SelectSubset<T, NotificationQueueCreateArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationQueues.
     * @param {NotificationQueueCreateManyArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationQueueCreateManyArgs>(args?: SelectSubset<T, NotificationQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationQueues and returns the data saved in the database.
     * @param {NotificationQueueCreateManyAndReturnArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationQueue.
     * @param {NotificationQueueDeleteArgs} args - Arguments to delete one NotificationQueue.
     * @example
     * // Delete one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.delete({
     *   where: {
     *     // ... filter to delete one NotificationQueue
     *   }
     * })
     * 
     */
    delete<T extends NotificationQueueDeleteArgs>(args: SelectSubset<T, NotificationQueueDeleteArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationQueue.
     * @param {NotificationQueueUpdateArgs} args - Arguments to update one NotificationQueue.
     * @example
     * // Update one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationQueueUpdateArgs>(args: SelectSubset<T, NotificationQueueUpdateArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationQueues.
     * @param {NotificationQueueDeleteManyArgs} args - Arguments to filter NotificationQueues to delete.
     * @example
     * // Delete a few NotificationQueues
     * const { count } = await prisma.notificationQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationQueueDeleteManyArgs>(args?: SelectSubset<T, NotificationQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationQueueUpdateManyArgs>(args: SelectSubset<T, NotificationQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationQueue.
     * @param {NotificationQueueUpsertArgs} args - Arguments to update or create a NotificationQueue.
     * @example
     * // Update or create a NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.upsert({
     *   create: {
     *     // ... data to create a NotificationQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationQueue we want to update
     *   }
     * })
     */
    upsert<T extends NotificationQueueUpsertArgs>(args: SelectSubset<T, NotificationQueueUpsertArgs<ExtArgs>>): Prisma__NotificationQueueClient<$Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueCountArgs} args - Arguments to filter NotificationQueues to count.
     * @example
     * // Count the number of NotificationQueues
     * const count = await prisma.notificationQueue.count({
     *   where: {
     *     // ... the filter for the NotificationQueues we want to count
     *   }
     * })
    **/
    count<T extends NotificationQueueCountArgs>(
      args?: Subset<T, NotificationQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationQueueAggregateArgs>(args: Subset<T, NotificationQueueAggregateArgs>): Prisma.PrismaPromise<GetNotificationQueueAggregateType<T>>

    /**
     * Group by NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationQueueGroupByArgs['orderBy'] }
        : { orderBy?: NotificationQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationQueue model
   */
  readonly fields: NotificationQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationQueue model
   */ 
  interface NotificationQueueFieldRefs {
    readonly id: FieldRef<"NotificationQueue", 'String'>
    readonly userId: FieldRef<"NotificationQueue", 'String'>
    readonly type: FieldRef<"NotificationQueue", 'String'>
    readonly priority: FieldRef<"NotificationQueue", 'Int'>
    readonly data: FieldRef<"NotificationQueue", 'Json'>
    readonly status: FieldRef<"NotificationQueue", 'String'>
    readonly attempts: FieldRef<"NotificationQueue", 'Int'>
    readonly maxAttempts: FieldRef<"NotificationQueue", 'Int'>
    readonly scheduledFor: FieldRef<"NotificationQueue", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationQueue", 'DateTime'>
    readonly lastAttemptAt: FieldRef<"NotificationQueue", 'DateTime'>
    readonly batchKey: FieldRef<"NotificationQueue", 'String'>
    readonly batchedAt: FieldRef<"NotificationQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationQueue findUnique
   */
  export type NotificationQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue findUniqueOrThrow
   */
  export type NotificationQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue findFirst
   */
  export type NotificationQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue findFirstOrThrow
   */
  export type NotificationQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue findMany
   */
  export type NotificationQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Filter, which NotificationQueues to fetch.
     */
    where?: NotificationQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?: NotificationQueueOrderByWithRelationInput | NotificationQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationQueues.
     */
    skip?: number
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[]
  }

  /**
   * NotificationQueue create
   */
  export type NotificationQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationQueue.
     */
    data: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>
  }

  /**
   * NotificationQueue createMany
   */
  export type NotificationQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationQueue createManyAndReturn
   */
  export type NotificationQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationQueue update
   */
  export type NotificationQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationQueue.
     */
    data: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>
    /**
     * Choose, which NotificationQueue to update.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue updateMany
   */
  export type NotificationQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput
  }

  /**
   * NotificationQueue upsert
   */
  export type NotificationQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationQueue to update in case it exists.
     */
    where: NotificationQueueWhereUniqueInput
    /**
     * In case the NotificationQueue found by the `where` argument doesn't exist, create a new NotificationQueue with this data.
     */
    create: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>
    /**
     * In case the NotificationQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>
  }

  /**
   * NotificationQueue delete
   */
  export type NotificationQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
    /**
     * Filter which NotificationQueue to delete.
     */
    where: NotificationQueueWhereUniqueInput
  }

  /**
   * NotificationQueue deleteMany
   */
  export type NotificationQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationQueues to delete
     */
    where?: NotificationQueueWhereInput
  }

  /**
   * NotificationQueue without action
   */
  export type NotificationQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    discordId: 'discordId',
    username: 'username',
    discriminator: 'discriminator',
    avatar: 'avatar',
    helpfulnessScore: 'helpfulnessScore',
    totalNotes: 'totalNotes',
    totalRatings: 'totalRatings',
    joinedAt: 'joinedAt',
    lastActiveAt: 'lastActiveAt',
    dailyRequestCount: 'dailyRequestCount',
    lastRequestDate: 'lastRequestDate',
    verifiedAt: 'verifiedAt',
    trustLevel: 'trustLevel',
    notifyNewRequests: 'notifyNewRequests',
    notifyNotePublished: 'notifyNotePublished',
    notifyNoteRatings: 'notifyNoteRatings',
    notifyStatusChanged: 'notifyStatusChanged',
    notifyMilestones: 'notifyMilestones',
    notificationBatching: 'notificationBatching',
    batchingInterval: 'batchingInterval',
    notificationMethods: 'notificationMethods',
    notificationsMutedUntil: 'notificationsMutedUntil'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ServerScalarFieldEnum: {
    id: 'id',
    discordId: 'discordId',
    name: 'name',
    icon: 'icon',
    enabled: 'enabled',
    joinedAt: 'joinedAt',
    allowNoteRequests: 'allowNoteRequests',
    allowNoteCreation: 'allowNoteCreation',
    maxRequestsPerUser: 'maxRequestsPerUser',
    requireVerification: 'requireVerification',
    enabledChannels: 'enabledChannels',
    disabledChannels: 'disabledChannels',
    moderatorRoles: 'moderatorRoles',
    contributorRoles: 'contributorRoles',
    isPaused: 'isPaused',
    pausedAt: 'pausedAt',
    pausedBy: 'pausedBy',
    pauseReason: 'pauseReason'
  };

  export type ServerScalarFieldEnum = (typeof ServerScalarFieldEnum)[keyof typeof ServerScalarFieldEnum]


  export const ServerMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serverId: 'serverId',
    roles: 'roles',
    joinedAt: 'joinedAt'
  };

  export type ServerMemberScalarFieldEnum = (typeof ServerMemberScalarFieldEnum)[keyof typeof ServerMemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    discordId: 'discordId',
    channelId: 'channelId',
    serverId: 'serverId',
    authorId: 'authorId',
    content: 'content',
    attachments: 'attachments',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    totalRequests: 'totalRequests',
    uniqueRequestors: 'uniqueRequestors',
    hasActiveNote: 'hasActiveNote'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NoteRequestScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    requestorId: 'requestorId',
    reason: 'reason',
    sources: 'sources',
    timestamp: 'timestamp',
    isActive: 'isActive'
  };

  export type NoteRequestScalarFieldEnum = (typeof NoteRequestScalarFieldEnum)[keyof typeof NoteRequestScalarFieldEnum]


  export const OpenNoteScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    authorId: 'authorId',
    content: 'content',
    classification: 'classification',
    sources: 'sources',
    status: 'status',
    submittedAt: 'submittedAt',
    lastStatusAt: 'lastStatusAt',
    helpfulCount: 'helpfulCount',
    notHelpfulCount: 'notHelpfulCount',
    totalRatings: 'totalRatings',
    helpfulnessRatio: 'helpfulnessRatio',
    isVisible: 'isVisible',
    visibilityScore: 'visibilityScore'
  };

  export type OpenNoteScalarFieldEnum = (typeof OpenNoteScalarFieldEnum)[keyof typeof OpenNoteScalarFieldEnum]


  export const NoteRatingScalarFieldEnum: {
    id: 'id',
    noteId: 'noteId',
    raterId: 'raterId',
    helpful: 'helpful',
    reason: 'reason',
    timestamp: 'timestamp',
    weight: 'weight'
  };

  export type NoteRatingScalarFieldEnum = (typeof NoteRatingScalarFieldEnum)[keyof typeof NoteRatingScalarFieldEnum]


  export const RequestAggregationScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    totalRequests: 'totalRequests',
    uniqueRequestors: 'uniqueRequestors',
    firstRequestAt: 'firstRequestAt',
    lastRequestAt: 'lastRequestAt',
    thresholdMet: 'thresholdMet',
    thresholdMetAt: 'thresholdMetAt',
    contributorsNotified: 'contributorsNotified',
    notifiedAt: 'notifiedAt'
  };

  export type RequestAggregationScalarFieldEnum = (typeof RequestAggregationScalarFieldEnum)[keyof typeof RequestAggregationScalarFieldEnum]


  export const RateLimitingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    limitType: 'limitType',
    count: 'count',
    resetAt: 'resetAt',
    createdAt: 'createdAt'
  };

  export type RateLimitingScalarFieldEnum = (typeof RateLimitingScalarFieldEnum)[keyof typeof RateLimitingScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    serverId: 'serverId',
    adminId: 'adminId',
    action: 'action',
    target: 'target',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ModerationQueueScalarFieldEnum: {
    id: 'id',
    serverId: 'serverId',
    itemType: 'itemType',
    itemId: 'itemId',
    flagType: 'flagType',
    flaggedBy: 'flaggedBy',
    reason: 'reason',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    actionTaken: 'actionTaken',
    createdAt: 'createdAt'
  };

  export type ModerationQueueScalarFieldEnum = (typeof ModerationQueueScalarFieldEnum)[keyof typeof ModerationQueueScalarFieldEnum]


  export const NotificationQueueScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    priority: 'priority',
    data: 'data',
    status: 'status',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    scheduledFor: 'scheduledFor',
    createdAt: 'createdAt',
    lastAttemptAt: 'lastAttemptAt',
    batchKey: 'batchKey',
    batchedAt: 'batchedAt'
  };

  export type NotificationQueueScalarFieldEnum = (typeof NotificationQueueScalarFieldEnum)[keyof typeof NotificationQueueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    discordId?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    discriminator?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    helpfulnessScore?: FloatFilter<"User"> | number
    totalNotes?: IntFilter<"User"> | number
    totalRatings?: IntFilter<"User"> | number
    joinedAt?: DateTimeFilter<"User"> | Date | string
    lastActiveAt?: DateTimeFilter<"User"> | Date | string
    dailyRequestCount?: IntFilter<"User"> | number
    lastRequestDate?: DateTimeNullableFilter<"User"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trustLevel?: StringFilter<"User"> | string
    notifyNewRequests?: BoolFilter<"User"> | boolean
    notifyNotePublished?: BoolFilter<"User"> | boolean
    notifyNoteRatings?: BoolFilter<"User"> | boolean
    notifyStatusChanged?: BoolFilter<"User"> | boolean
    notifyMilestones?: BoolFilter<"User"> | boolean
    notificationBatching?: BoolFilter<"User"> | boolean
    batchingInterval?: IntFilter<"User"> | number
    notificationMethods?: StringNullableListFilter<"User">
    notificationsMutedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    noteRequests?: NoteRequestListRelationFilter
    communityNotes?: OpenNoteListRelationFilter
    noteRatings?: NoteRatingListRelationFilter
    serverMemberships?: ServerMemberListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    discriminator?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    dailyRequestCount?: SortOrder
    lastRequestDate?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    trustLevel?: SortOrder
    notifyNewRequests?: SortOrder
    notifyNotePublished?: SortOrder
    notifyNoteRatings?: SortOrder
    notifyStatusChanged?: SortOrder
    notifyMilestones?: SortOrder
    notificationBatching?: SortOrder
    batchingInterval?: SortOrder
    notificationMethods?: SortOrder
    notificationsMutedUntil?: SortOrderInput | SortOrder
    noteRequests?: NoteRequestOrderByRelationAggregateInput
    communityNotes?: OpenNoteOrderByRelationAggregateInput
    noteRatings?: NoteRatingOrderByRelationAggregateInput
    serverMemberships?: ServerMemberOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    discordId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    discriminator?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    helpfulnessScore?: FloatFilter<"User"> | number
    totalNotes?: IntFilter<"User"> | number
    totalRatings?: IntFilter<"User"> | number
    joinedAt?: DateTimeFilter<"User"> | Date | string
    lastActiveAt?: DateTimeFilter<"User"> | Date | string
    dailyRequestCount?: IntFilter<"User"> | number
    lastRequestDate?: DateTimeNullableFilter<"User"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trustLevel?: StringFilter<"User"> | string
    notifyNewRequests?: BoolFilter<"User"> | boolean
    notifyNotePublished?: BoolFilter<"User"> | boolean
    notifyNoteRatings?: BoolFilter<"User"> | boolean
    notifyStatusChanged?: BoolFilter<"User"> | boolean
    notifyMilestones?: BoolFilter<"User"> | boolean
    notificationBatching?: BoolFilter<"User"> | boolean
    batchingInterval?: IntFilter<"User"> | number
    notificationMethods?: StringNullableListFilter<"User">
    notificationsMutedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    noteRequests?: NoteRequestListRelationFilter
    communityNotes?: OpenNoteListRelationFilter
    noteRatings?: NoteRatingListRelationFilter
    serverMemberships?: ServerMemberListRelationFilter
  }, "id" | "discordId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    discriminator?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    dailyRequestCount?: SortOrder
    lastRequestDate?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    trustLevel?: SortOrder
    notifyNewRequests?: SortOrder
    notifyNotePublished?: SortOrder
    notifyNoteRatings?: SortOrder
    notifyStatusChanged?: SortOrder
    notifyMilestones?: SortOrder
    notificationBatching?: SortOrder
    batchingInterval?: SortOrder
    notificationMethods?: SortOrder
    notificationsMutedUntil?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    discordId?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    discriminator?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    helpfulnessScore?: FloatWithAggregatesFilter<"User"> | number
    totalNotes?: IntWithAggregatesFilter<"User"> | number
    totalRatings?: IntWithAggregatesFilter<"User"> | number
    joinedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastActiveAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    dailyRequestCount?: IntWithAggregatesFilter<"User"> | number
    lastRequestDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    trustLevel?: StringWithAggregatesFilter<"User"> | string
    notifyNewRequests?: BoolWithAggregatesFilter<"User"> | boolean
    notifyNotePublished?: BoolWithAggregatesFilter<"User"> | boolean
    notifyNoteRatings?: BoolWithAggregatesFilter<"User"> | boolean
    notifyStatusChanged?: BoolWithAggregatesFilter<"User"> | boolean
    notifyMilestones?: BoolWithAggregatesFilter<"User"> | boolean
    notificationBatching?: BoolWithAggregatesFilter<"User"> | boolean
    batchingInterval?: IntWithAggregatesFilter<"User"> | number
    notificationMethods?: StringNullableListFilter<"User">
    notificationsMutedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ServerWhereInput = {
    AND?: ServerWhereInput | ServerWhereInput[]
    OR?: ServerWhereInput[]
    NOT?: ServerWhereInput | ServerWhereInput[]
    id?: StringFilter<"Server"> | string
    discordId?: StringFilter<"Server"> | string
    name?: StringFilter<"Server"> | string
    icon?: StringNullableFilter<"Server"> | string | null
    enabled?: BoolFilter<"Server"> | boolean
    joinedAt?: DateTimeFilter<"Server"> | Date | string
    allowNoteRequests?: BoolFilter<"Server"> | boolean
    allowNoteCreation?: BoolFilter<"Server"> | boolean
    maxRequestsPerUser?: IntFilter<"Server"> | number
    requireVerification?: BoolFilter<"Server"> | boolean
    enabledChannels?: StringNullableListFilter<"Server">
    disabledChannels?: StringNullableListFilter<"Server">
    moderatorRoles?: StringNullableListFilter<"Server">
    contributorRoles?: StringNullableListFilter<"Server">
    isPaused?: BoolFilter<"Server"> | boolean
    pausedAt?: DateTimeNullableFilter<"Server"> | Date | string | null
    pausedBy?: StringNullableFilter<"Server"> | string | null
    pauseReason?: StringNullableFilter<"Server"> | string | null
    messages?: MessageListRelationFilter
    serverMembers?: ServerMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type ServerOrderByWithRelationInput = {
    id?: SortOrder
    discordId?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    enabled?: SortOrder
    joinedAt?: SortOrder
    allowNoteRequests?: SortOrder
    allowNoteCreation?: SortOrder
    maxRequestsPerUser?: SortOrder
    requireVerification?: SortOrder
    enabledChannels?: SortOrder
    disabledChannels?: SortOrder
    moderatorRoles?: SortOrder
    contributorRoles?: SortOrder
    isPaused?: SortOrder
    pausedAt?: SortOrderInput | SortOrder
    pausedBy?: SortOrderInput | SortOrder
    pauseReason?: SortOrderInput | SortOrder
    messages?: MessageOrderByRelationAggregateInput
    serverMembers?: ServerMemberOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type ServerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    discordId?: string
    AND?: ServerWhereInput | ServerWhereInput[]
    OR?: ServerWhereInput[]
    NOT?: ServerWhereInput | ServerWhereInput[]
    name?: StringFilter<"Server"> | string
    icon?: StringNullableFilter<"Server"> | string | null
    enabled?: BoolFilter<"Server"> | boolean
    joinedAt?: DateTimeFilter<"Server"> | Date | string
    allowNoteRequests?: BoolFilter<"Server"> | boolean
    allowNoteCreation?: BoolFilter<"Server"> | boolean
    maxRequestsPerUser?: IntFilter<"Server"> | number
    requireVerification?: BoolFilter<"Server"> | boolean
    enabledChannels?: StringNullableListFilter<"Server">
    disabledChannels?: StringNullableListFilter<"Server">
    moderatorRoles?: StringNullableListFilter<"Server">
    contributorRoles?: StringNullableListFilter<"Server">
    isPaused?: BoolFilter<"Server"> | boolean
    pausedAt?: DateTimeNullableFilter<"Server"> | Date | string | null
    pausedBy?: StringNullableFilter<"Server"> | string | null
    pauseReason?: StringNullableFilter<"Server"> | string | null
    messages?: MessageListRelationFilter
    serverMembers?: ServerMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "discordId">

  export type ServerOrderByWithAggregationInput = {
    id?: SortOrder
    discordId?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    enabled?: SortOrder
    joinedAt?: SortOrder
    allowNoteRequests?: SortOrder
    allowNoteCreation?: SortOrder
    maxRequestsPerUser?: SortOrder
    requireVerification?: SortOrder
    enabledChannels?: SortOrder
    disabledChannels?: SortOrder
    moderatorRoles?: SortOrder
    contributorRoles?: SortOrder
    isPaused?: SortOrder
    pausedAt?: SortOrderInput | SortOrder
    pausedBy?: SortOrderInput | SortOrder
    pauseReason?: SortOrderInput | SortOrder
    _count?: ServerCountOrderByAggregateInput
    _avg?: ServerAvgOrderByAggregateInput
    _max?: ServerMaxOrderByAggregateInput
    _min?: ServerMinOrderByAggregateInput
    _sum?: ServerSumOrderByAggregateInput
  }

  export type ServerScalarWhereWithAggregatesInput = {
    AND?: ServerScalarWhereWithAggregatesInput | ServerScalarWhereWithAggregatesInput[]
    OR?: ServerScalarWhereWithAggregatesInput[]
    NOT?: ServerScalarWhereWithAggregatesInput | ServerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Server"> | string
    discordId?: StringWithAggregatesFilter<"Server"> | string
    name?: StringWithAggregatesFilter<"Server"> | string
    icon?: StringNullableWithAggregatesFilter<"Server"> | string | null
    enabled?: BoolWithAggregatesFilter<"Server"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"Server"> | Date | string
    allowNoteRequests?: BoolWithAggregatesFilter<"Server"> | boolean
    allowNoteCreation?: BoolWithAggregatesFilter<"Server"> | boolean
    maxRequestsPerUser?: IntWithAggregatesFilter<"Server"> | number
    requireVerification?: BoolWithAggregatesFilter<"Server"> | boolean
    enabledChannels?: StringNullableListFilter<"Server">
    disabledChannels?: StringNullableListFilter<"Server">
    moderatorRoles?: StringNullableListFilter<"Server">
    contributorRoles?: StringNullableListFilter<"Server">
    isPaused?: BoolWithAggregatesFilter<"Server"> | boolean
    pausedAt?: DateTimeNullableWithAggregatesFilter<"Server"> | Date | string | null
    pausedBy?: StringNullableWithAggregatesFilter<"Server"> | string | null
    pauseReason?: StringNullableWithAggregatesFilter<"Server"> | string | null
  }

  export type ServerMemberWhereInput = {
    AND?: ServerMemberWhereInput | ServerMemberWhereInput[]
    OR?: ServerMemberWhereInput[]
    NOT?: ServerMemberWhereInput | ServerMemberWhereInput[]
    id?: StringFilter<"ServerMember"> | string
    userId?: StringFilter<"ServerMember"> | string
    serverId?: StringFilter<"ServerMember"> | string
    roles?: StringNullableListFilter<"ServerMember">
    joinedAt?: DateTimeFilter<"ServerMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    server?: XOR<ServerRelationFilter, ServerWhereInput>
  }

  export type ServerMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serverId?: SortOrder
    roles?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    server?: ServerOrderByWithRelationInput
  }

  export type ServerMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_serverId?: ServerMemberUserIdServerIdCompoundUniqueInput
    AND?: ServerMemberWhereInput | ServerMemberWhereInput[]
    OR?: ServerMemberWhereInput[]
    NOT?: ServerMemberWhereInput | ServerMemberWhereInput[]
    userId?: StringFilter<"ServerMember"> | string
    serverId?: StringFilter<"ServerMember"> | string
    roles?: StringNullableListFilter<"ServerMember">
    joinedAt?: DateTimeFilter<"ServerMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    server?: XOR<ServerRelationFilter, ServerWhereInput>
  }, "id" | "userId_serverId">

  export type ServerMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serverId?: SortOrder
    roles?: SortOrder
    joinedAt?: SortOrder
    _count?: ServerMemberCountOrderByAggregateInput
    _max?: ServerMemberMaxOrderByAggregateInput
    _min?: ServerMemberMinOrderByAggregateInput
  }

  export type ServerMemberScalarWhereWithAggregatesInput = {
    AND?: ServerMemberScalarWhereWithAggregatesInput | ServerMemberScalarWhereWithAggregatesInput[]
    OR?: ServerMemberScalarWhereWithAggregatesInput[]
    NOT?: ServerMemberScalarWhereWithAggregatesInput | ServerMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServerMember"> | string
    userId?: StringWithAggregatesFilter<"ServerMember"> | string
    serverId?: StringWithAggregatesFilter<"ServerMember"> | string
    roles?: StringNullableListFilter<"ServerMember">
    joinedAt?: DateTimeWithAggregatesFilter<"ServerMember"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    discordId?: StringFilter<"Message"> | string
    channelId?: StringFilter<"Message"> | string
    serverId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    timestamp?: DateTimeFilter<"Message"> | Date | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    totalRequests?: IntFilter<"Message"> | number
    uniqueRequestors?: IntFilter<"Message"> | number
    hasActiveNote?: BoolFilter<"Message"> | boolean
    server?: XOR<ServerRelationFilter, ServerWhereInput>
    noteRequests?: NoteRequestListRelationFilter
    communityNotes?: OpenNoteListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    discordId?: SortOrder
    channelId?: SortOrder
    serverId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    hasActiveNote?: SortOrder
    server?: ServerOrderByWithRelationInput
    noteRequests?: NoteRequestOrderByRelationAggregateInput
    communityNotes?: OpenNoteOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    discordId?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    channelId?: StringFilter<"Message"> | string
    serverId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    timestamp?: DateTimeFilter<"Message"> | Date | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    totalRequests?: IntFilter<"Message"> | number
    uniqueRequestors?: IntFilter<"Message"> | number
    hasActiveNote?: BoolFilter<"Message"> | boolean
    server?: XOR<ServerRelationFilter, ServerWhereInput>
    noteRequests?: NoteRequestListRelationFilter
    communityNotes?: OpenNoteListRelationFilter
  }, "id" | "discordId">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    discordId?: SortOrder
    channelId?: SortOrder
    serverId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    hasActiveNote?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    discordId?: StringWithAggregatesFilter<"Message"> | string
    channelId?: StringWithAggregatesFilter<"Message"> | string
    serverId?: StringWithAggregatesFilter<"Message"> | string
    authorId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    totalRequests?: IntWithAggregatesFilter<"Message"> | number
    uniqueRequestors?: IntWithAggregatesFilter<"Message"> | number
    hasActiveNote?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type NoteRequestWhereInput = {
    AND?: NoteRequestWhereInput | NoteRequestWhereInput[]
    OR?: NoteRequestWhereInput[]
    NOT?: NoteRequestWhereInput | NoteRequestWhereInput[]
    id?: StringFilter<"NoteRequest"> | string
    messageId?: StringFilter<"NoteRequest"> | string
    requestorId?: StringFilter<"NoteRequest"> | string
    reason?: StringNullableFilter<"NoteRequest"> | string | null
    sources?: StringNullableListFilter<"NoteRequest">
    timestamp?: DateTimeFilter<"NoteRequest"> | Date | string
    isActive?: BoolFilter<"NoteRequest"> | boolean
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    requestor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoteRequestOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    requestorId?: SortOrder
    reason?: SortOrderInput | SortOrder
    sources?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    message?: MessageOrderByWithRelationInput
    requestor?: UserOrderByWithRelationInput
  }

  export type NoteRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_requestorId?: NoteRequestMessageIdRequestorIdCompoundUniqueInput
    AND?: NoteRequestWhereInput | NoteRequestWhereInput[]
    OR?: NoteRequestWhereInput[]
    NOT?: NoteRequestWhereInput | NoteRequestWhereInput[]
    messageId?: StringFilter<"NoteRequest"> | string
    requestorId?: StringFilter<"NoteRequest"> | string
    reason?: StringNullableFilter<"NoteRequest"> | string | null
    sources?: StringNullableListFilter<"NoteRequest">
    timestamp?: DateTimeFilter<"NoteRequest"> | Date | string
    isActive?: BoolFilter<"NoteRequest"> | boolean
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    requestor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_requestorId">

  export type NoteRequestOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    requestorId?: SortOrder
    reason?: SortOrderInput | SortOrder
    sources?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    _count?: NoteRequestCountOrderByAggregateInput
    _max?: NoteRequestMaxOrderByAggregateInput
    _min?: NoteRequestMinOrderByAggregateInput
  }

  export type NoteRequestScalarWhereWithAggregatesInput = {
    AND?: NoteRequestScalarWhereWithAggregatesInput | NoteRequestScalarWhereWithAggregatesInput[]
    OR?: NoteRequestScalarWhereWithAggregatesInput[]
    NOT?: NoteRequestScalarWhereWithAggregatesInput | NoteRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NoteRequest"> | string
    messageId?: StringWithAggregatesFilter<"NoteRequest"> | string
    requestorId?: StringWithAggregatesFilter<"NoteRequest"> | string
    reason?: StringNullableWithAggregatesFilter<"NoteRequest"> | string | null
    sources?: StringNullableListFilter<"NoteRequest">
    timestamp?: DateTimeWithAggregatesFilter<"NoteRequest"> | Date | string
    isActive?: BoolWithAggregatesFilter<"NoteRequest"> | boolean
  }

  export type OpenNoteWhereInput = {
    AND?: OpenNoteWhereInput | OpenNoteWhereInput[]
    OR?: OpenNoteWhereInput[]
    NOT?: OpenNoteWhereInput | OpenNoteWhereInput[]
    id?: StringFilter<"OpenNote"> | string
    messageId?: StringFilter<"OpenNote"> | string
    authorId?: StringFilter<"OpenNote"> | string
    content?: StringFilter<"OpenNote"> | string
    classification?: StringFilter<"OpenNote"> | string
    sources?: StringNullableListFilter<"OpenNote">
    status?: StringFilter<"OpenNote"> | string
    submittedAt?: DateTimeFilter<"OpenNote"> | Date | string
    lastStatusAt?: DateTimeFilter<"OpenNote"> | Date | string
    helpfulCount?: IntFilter<"OpenNote"> | number
    notHelpfulCount?: IntFilter<"OpenNote"> | number
    totalRatings?: IntFilter<"OpenNote"> | number
    helpfulnessRatio?: FloatFilter<"OpenNote"> | number
    isVisible?: BoolFilter<"OpenNote"> | boolean
    visibilityScore?: FloatFilter<"OpenNote"> | number
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    ratings?: NoteRatingListRelationFilter
  }

  export type OpenNoteOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    classification?: SortOrder
    sources?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastStatusAt?: SortOrder
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    isVisible?: SortOrder
    visibilityScore?: SortOrder
    message?: MessageOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    ratings?: NoteRatingOrderByRelationAggregateInput
  }

  export type OpenNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpenNoteWhereInput | OpenNoteWhereInput[]
    OR?: OpenNoteWhereInput[]
    NOT?: OpenNoteWhereInput | OpenNoteWhereInput[]
    messageId?: StringFilter<"OpenNote"> | string
    authorId?: StringFilter<"OpenNote"> | string
    content?: StringFilter<"OpenNote"> | string
    classification?: StringFilter<"OpenNote"> | string
    sources?: StringNullableListFilter<"OpenNote">
    status?: StringFilter<"OpenNote"> | string
    submittedAt?: DateTimeFilter<"OpenNote"> | Date | string
    lastStatusAt?: DateTimeFilter<"OpenNote"> | Date | string
    helpfulCount?: IntFilter<"OpenNote"> | number
    notHelpfulCount?: IntFilter<"OpenNote"> | number
    totalRatings?: IntFilter<"OpenNote"> | number
    helpfulnessRatio?: FloatFilter<"OpenNote"> | number
    isVisible?: BoolFilter<"OpenNote"> | boolean
    visibilityScore?: FloatFilter<"OpenNote"> | number
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    ratings?: NoteRatingListRelationFilter
  }, "id">

  export type OpenNoteOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    classification?: SortOrder
    sources?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastStatusAt?: SortOrder
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    isVisible?: SortOrder
    visibilityScore?: SortOrder
    _count?: OpenNoteCountOrderByAggregateInput
    _avg?: OpenNoteAvgOrderByAggregateInput
    _max?: OpenNoteMaxOrderByAggregateInput
    _min?: OpenNoteMinOrderByAggregateInput
    _sum?: OpenNoteSumOrderByAggregateInput
  }

  export type OpenNoteScalarWhereWithAggregatesInput = {
    AND?: OpenNoteScalarWhereWithAggregatesInput | OpenNoteScalarWhereWithAggregatesInput[]
    OR?: OpenNoteScalarWhereWithAggregatesInput[]
    NOT?: OpenNoteScalarWhereWithAggregatesInput | OpenNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpenNote"> | string
    messageId?: StringWithAggregatesFilter<"OpenNote"> | string
    authorId?: StringWithAggregatesFilter<"OpenNote"> | string
    content?: StringWithAggregatesFilter<"OpenNote"> | string
    classification?: StringWithAggregatesFilter<"OpenNote"> | string
    sources?: StringNullableListFilter<"OpenNote">
    status?: StringWithAggregatesFilter<"OpenNote"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"OpenNote"> | Date | string
    lastStatusAt?: DateTimeWithAggregatesFilter<"OpenNote"> | Date | string
    helpfulCount?: IntWithAggregatesFilter<"OpenNote"> | number
    notHelpfulCount?: IntWithAggregatesFilter<"OpenNote"> | number
    totalRatings?: IntWithAggregatesFilter<"OpenNote"> | number
    helpfulnessRatio?: FloatWithAggregatesFilter<"OpenNote"> | number
    isVisible?: BoolWithAggregatesFilter<"OpenNote"> | boolean
    visibilityScore?: FloatWithAggregatesFilter<"OpenNote"> | number
  }

  export type NoteRatingWhereInput = {
    AND?: NoteRatingWhereInput | NoteRatingWhereInput[]
    OR?: NoteRatingWhereInput[]
    NOT?: NoteRatingWhereInput | NoteRatingWhereInput[]
    id?: StringFilter<"NoteRating"> | string
    noteId?: StringFilter<"NoteRating"> | string
    raterId?: StringFilter<"NoteRating"> | string
    helpful?: BoolFilter<"NoteRating"> | boolean
    reason?: StringNullableFilter<"NoteRating"> | string | null
    timestamp?: DateTimeFilter<"NoteRating"> | Date | string
    weight?: FloatFilter<"NoteRating"> | number
    note?: XOR<OpenNoteRelationFilter, OpenNoteWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoteRatingOrderByWithRelationInput = {
    id?: SortOrder
    noteId?: SortOrder
    raterId?: SortOrder
    helpful?: SortOrder
    reason?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    weight?: SortOrder
    note?: OpenNoteOrderByWithRelationInput
    rater?: UserOrderByWithRelationInput
  }

  export type NoteRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    noteId_raterId?: NoteRatingNoteIdRaterIdCompoundUniqueInput
    AND?: NoteRatingWhereInput | NoteRatingWhereInput[]
    OR?: NoteRatingWhereInput[]
    NOT?: NoteRatingWhereInput | NoteRatingWhereInput[]
    noteId?: StringFilter<"NoteRating"> | string
    raterId?: StringFilter<"NoteRating"> | string
    helpful?: BoolFilter<"NoteRating"> | boolean
    reason?: StringNullableFilter<"NoteRating"> | string | null
    timestamp?: DateTimeFilter<"NoteRating"> | Date | string
    weight?: FloatFilter<"NoteRating"> | number
    note?: XOR<OpenNoteRelationFilter, OpenNoteWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "noteId_raterId">

  export type NoteRatingOrderByWithAggregationInput = {
    id?: SortOrder
    noteId?: SortOrder
    raterId?: SortOrder
    helpful?: SortOrder
    reason?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    weight?: SortOrder
    _count?: NoteRatingCountOrderByAggregateInput
    _avg?: NoteRatingAvgOrderByAggregateInput
    _max?: NoteRatingMaxOrderByAggregateInput
    _min?: NoteRatingMinOrderByAggregateInput
    _sum?: NoteRatingSumOrderByAggregateInput
  }

  export type NoteRatingScalarWhereWithAggregatesInput = {
    AND?: NoteRatingScalarWhereWithAggregatesInput | NoteRatingScalarWhereWithAggregatesInput[]
    OR?: NoteRatingScalarWhereWithAggregatesInput[]
    NOT?: NoteRatingScalarWhereWithAggregatesInput | NoteRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NoteRating"> | string
    noteId?: StringWithAggregatesFilter<"NoteRating"> | string
    raterId?: StringWithAggregatesFilter<"NoteRating"> | string
    helpful?: BoolWithAggregatesFilter<"NoteRating"> | boolean
    reason?: StringNullableWithAggregatesFilter<"NoteRating"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"NoteRating"> | Date | string
    weight?: FloatWithAggregatesFilter<"NoteRating"> | number
  }

  export type RequestAggregationWhereInput = {
    AND?: RequestAggregationWhereInput | RequestAggregationWhereInput[]
    OR?: RequestAggregationWhereInput[]
    NOT?: RequestAggregationWhereInput | RequestAggregationWhereInput[]
    id?: StringFilter<"RequestAggregation"> | string
    messageId?: StringFilter<"RequestAggregation"> | string
    totalRequests?: IntFilter<"RequestAggregation"> | number
    uniqueRequestors?: IntFilter<"RequestAggregation"> | number
    firstRequestAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
    lastRequestAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
    thresholdMet?: BoolFilter<"RequestAggregation"> | boolean
    thresholdMetAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
    contributorsNotified?: BoolFilter<"RequestAggregation"> | boolean
    notifiedAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
  }

  export type RequestAggregationOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    firstRequestAt?: SortOrderInput | SortOrder
    lastRequestAt?: SortOrderInput | SortOrder
    thresholdMet?: SortOrder
    thresholdMetAt?: SortOrderInput | SortOrder
    contributorsNotified?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
  }

  export type RequestAggregationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: RequestAggregationWhereInput | RequestAggregationWhereInput[]
    OR?: RequestAggregationWhereInput[]
    NOT?: RequestAggregationWhereInput | RequestAggregationWhereInput[]
    totalRequests?: IntFilter<"RequestAggregation"> | number
    uniqueRequestors?: IntFilter<"RequestAggregation"> | number
    firstRequestAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
    lastRequestAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
    thresholdMet?: BoolFilter<"RequestAggregation"> | boolean
    thresholdMetAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
    contributorsNotified?: BoolFilter<"RequestAggregation"> | boolean
    notifiedAt?: DateTimeNullableFilter<"RequestAggregation"> | Date | string | null
  }, "id" | "messageId">

  export type RequestAggregationOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    firstRequestAt?: SortOrderInput | SortOrder
    lastRequestAt?: SortOrderInput | SortOrder
    thresholdMet?: SortOrder
    thresholdMetAt?: SortOrderInput | SortOrder
    contributorsNotified?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    _count?: RequestAggregationCountOrderByAggregateInput
    _avg?: RequestAggregationAvgOrderByAggregateInput
    _max?: RequestAggregationMaxOrderByAggregateInput
    _min?: RequestAggregationMinOrderByAggregateInput
    _sum?: RequestAggregationSumOrderByAggregateInput
  }

  export type RequestAggregationScalarWhereWithAggregatesInput = {
    AND?: RequestAggregationScalarWhereWithAggregatesInput | RequestAggregationScalarWhereWithAggregatesInput[]
    OR?: RequestAggregationScalarWhereWithAggregatesInput[]
    NOT?: RequestAggregationScalarWhereWithAggregatesInput | RequestAggregationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequestAggregation"> | string
    messageId?: StringWithAggregatesFilter<"RequestAggregation"> | string
    totalRequests?: IntWithAggregatesFilter<"RequestAggregation"> | number
    uniqueRequestors?: IntWithAggregatesFilter<"RequestAggregation"> | number
    firstRequestAt?: DateTimeNullableWithAggregatesFilter<"RequestAggregation"> | Date | string | null
    lastRequestAt?: DateTimeNullableWithAggregatesFilter<"RequestAggregation"> | Date | string | null
    thresholdMet?: BoolWithAggregatesFilter<"RequestAggregation"> | boolean
    thresholdMetAt?: DateTimeNullableWithAggregatesFilter<"RequestAggregation"> | Date | string | null
    contributorsNotified?: BoolWithAggregatesFilter<"RequestAggregation"> | boolean
    notifiedAt?: DateTimeNullableWithAggregatesFilter<"RequestAggregation"> | Date | string | null
  }

  export type RateLimitingWhereInput = {
    AND?: RateLimitingWhereInput | RateLimitingWhereInput[]
    OR?: RateLimitingWhereInput[]
    NOT?: RateLimitingWhereInput | RateLimitingWhereInput[]
    id?: StringFilter<"RateLimiting"> | string
    userId?: StringFilter<"RateLimiting"> | string
    limitType?: StringFilter<"RateLimiting"> | string
    count?: IntFilter<"RateLimiting"> | number
    resetAt?: DateTimeFilter<"RateLimiting"> | Date | string
    createdAt?: DateTimeFilter<"RateLimiting"> | Date | string
  }

  export type RateLimitingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    limitType?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_limitType?: RateLimitingUserIdLimitTypeCompoundUniqueInput
    AND?: RateLimitingWhereInput | RateLimitingWhereInput[]
    OR?: RateLimitingWhereInput[]
    NOT?: RateLimitingWhereInput | RateLimitingWhereInput[]
    userId?: StringFilter<"RateLimiting"> | string
    limitType?: StringFilter<"RateLimiting"> | string
    count?: IntFilter<"RateLimiting"> | number
    resetAt?: DateTimeFilter<"RateLimiting"> | Date | string
    createdAt?: DateTimeFilter<"RateLimiting"> | Date | string
  }, "id" | "userId_limitType">

  export type RateLimitingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    limitType?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
    _count?: RateLimitingCountOrderByAggregateInput
    _avg?: RateLimitingAvgOrderByAggregateInput
    _max?: RateLimitingMaxOrderByAggregateInput
    _min?: RateLimitingMinOrderByAggregateInput
    _sum?: RateLimitingSumOrderByAggregateInput
  }

  export type RateLimitingScalarWhereWithAggregatesInput = {
    AND?: RateLimitingScalarWhereWithAggregatesInput | RateLimitingScalarWhereWithAggregatesInput[]
    OR?: RateLimitingScalarWhereWithAggregatesInput[]
    NOT?: RateLimitingScalarWhereWithAggregatesInput | RateLimitingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RateLimiting"> | string
    userId?: StringWithAggregatesFilter<"RateLimiting"> | string
    limitType?: StringWithAggregatesFilter<"RateLimiting"> | string
    count?: IntWithAggregatesFilter<"RateLimiting"> | number
    resetAt?: DateTimeWithAggregatesFilter<"RateLimiting"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RateLimiting"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    serverId?: StringFilter<"AuditLog"> | string
    adminId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    server?: XOR<ServerRelationFilter, ServerWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    serverId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    server?: ServerOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    serverId?: StringFilter<"AuditLog"> | string
    adminId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    server?: XOR<ServerRelationFilter, ServerWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    serverId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    serverId?: StringWithAggregatesFilter<"AuditLog"> | string
    adminId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    target?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ModerationQueueWhereInput = {
    AND?: ModerationQueueWhereInput | ModerationQueueWhereInput[]
    OR?: ModerationQueueWhereInput[]
    NOT?: ModerationQueueWhereInput | ModerationQueueWhereInput[]
    id?: StringFilter<"ModerationQueue"> | string
    serverId?: StringFilter<"ModerationQueue"> | string
    itemType?: StringFilter<"ModerationQueue"> | string
    itemId?: StringFilter<"ModerationQueue"> | string
    flagType?: StringFilter<"ModerationQueue"> | string
    flaggedBy?: StringFilter<"ModerationQueue"> | string
    reason?: StringNullableFilter<"ModerationQueue"> | string | null
    status?: StringFilter<"ModerationQueue"> | string
    reviewedBy?: StringNullableFilter<"ModerationQueue"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ModerationQueue"> | Date | string | null
    actionTaken?: StringNullableFilter<"ModerationQueue"> | string | null
    createdAt?: DateTimeFilter<"ModerationQueue"> | Date | string
  }

  export type ModerationQueueOrderByWithRelationInput = {
    id?: SortOrder
    serverId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    flagType?: SortOrder
    flaggedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ModerationQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModerationQueueWhereInput | ModerationQueueWhereInput[]
    OR?: ModerationQueueWhereInput[]
    NOT?: ModerationQueueWhereInput | ModerationQueueWhereInput[]
    serverId?: StringFilter<"ModerationQueue"> | string
    itemType?: StringFilter<"ModerationQueue"> | string
    itemId?: StringFilter<"ModerationQueue"> | string
    flagType?: StringFilter<"ModerationQueue"> | string
    flaggedBy?: StringFilter<"ModerationQueue"> | string
    reason?: StringNullableFilter<"ModerationQueue"> | string | null
    status?: StringFilter<"ModerationQueue"> | string
    reviewedBy?: StringNullableFilter<"ModerationQueue"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ModerationQueue"> | Date | string | null
    actionTaken?: StringNullableFilter<"ModerationQueue"> | string | null
    createdAt?: DateTimeFilter<"ModerationQueue"> | Date | string
  }, "id">

  export type ModerationQueueOrderByWithAggregationInput = {
    id?: SortOrder
    serverId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    flagType?: SortOrder
    flaggedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ModerationQueueCountOrderByAggregateInput
    _max?: ModerationQueueMaxOrderByAggregateInput
    _min?: ModerationQueueMinOrderByAggregateInput
  }

  export type ModerationQueueScalarWhereWithAggregatesInput = {
    AND?: ModerationQueueScalarWhereWithAggregatesInput | ModerationQueueScalarWhereWithAggregatesInput[]
    OR?: ModerationQueueScalarWhereWithAggregatesInput[]
    NOT?: ModerationQueueScalarWhereWithAggregatesInput | ModerationQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModerationQueue"> | string
    serverId?: StringWithAggregatesFilter<"ModerationQueue"> | string
    itemType?: StringWithAggregatesFilter<"ModerationQueue"> | string
    itemId?: StringWithAggregatesFilter<"ModerationQueue"> | string
    flagType?: StringWithAggregatesFilter<"ModerationQueue"> | string
    flaggedBy?: StringWithAggregatesFilter<"ModerationQueue"> | string
    reason?: StringNullableWithAggregatesFilter<"ModerationQueue"> | string | null
    status?: StringWithAggregatesFilter<"ModerationQueue"> | string
    reviewedBy?: StringNullableWithAggregatesFilter<"ModerationQueue"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ModerationQueue"> | Date | string | null
    actionTaken?: StringNullableWithAggregatesFilter<"ModerationQueue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModerationQueue"> | Date | string
  }

  export type NotificationQueueWhereInput = {
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    OR?: NotificationQueueWhereInput[]
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    id?: StringFilter<"NotificationQueue"> | string
    userId?: StringFilter<"NotificationQueue"> | string
    type?: StringFilter<"NotificationQueue"> | string
    priority?: IntFilter<"NotificationQueue"> | number
    data?: JsonFilter<"NotificationQueue">
    status?: StringFilter<"NotificationQueue"> | string
    attempts?: IntFilter<"NotificationQueue"> | number
    maxAttempts?: IntFilter<"NotificationQueue"> | number
    scheduledFor?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationQueue"> | Date | string
    lastAttemptAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    batchKey?: StringNullableFilter<"NotificationQueue"> | string | null
    batchedAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
  }

  export type NotificationQueueOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    data?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    batchKey?: SortOrderInput | SortOrder
    batchedAt?: SortOrderInput | SortOrder
  }

  export type NotificationQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    OR?: NotificationQueueWhereInput[]
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[]
    userId?: StringFilter<"NotificationQueue"> | string
    type?: StringFilter<"NotificationQueue"> | string
    priority?: IntFilter<"NotificationQueue"> | number
    data?: JsonFilter<"NotificationQueue">
    status?: StringFilter<"NotificationQueue"> | string
    attempts?: IntFilter<"NotificationQueue"> | number
    maxAttempts?: IntFilter<"NotificationQueue"> | number
    scheduledFor?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationQueue"> | Date | string
    lastAttemptAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
    batchKey?: StringNullableFilter<"NotificationQueue"> | string | null
    batchedAt?: DateTimeNullableFilter<"NotificationQueue"> | Date | string | null
  }, "id">

  export type NotificationQueueOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    data?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    batchKey?: SortOrderInput | SortOrder
    batchedAt?: SortOrderInput | SortOrder
    _count?: NotificationQueueCountOrderByAggregateInput
    _avg?: NotificationQueueAvgOrderByAggregateInput
    _max?: NotificationQueueMaxOrderByAggregateInput
    _min?: NotificationQueueMinOrderByAggregateInput
    _sum?: NotificationQueueSumOrderByAggregateInput
  }

  export type NotificationQueueScalarWhereWithAggregatesInput = {
    AND?: NotificationQueueScalarWhereWithAggregatesInput | NotificationQueueScalarWhereWithAggregatesInput[]
    OR?: NotificationQueueScalarWhereWithAggregatesInput[]
    NOT?: NotificationQueueScalarWhereWithAggregatesInput | NotificationQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationQueue"> | string
    userId?: StringWithAggregatesFilter<"NotificationQueue"> | string
    type?: StringWithAggregatesFilter<"NotificationQueue"> | string
    priority?: IntWithAggregatesFilter<"NotificationQueue"> | number
    data?: JsonWithAggregatesFilter<"NotificationQueue">
    status?: StringWithAggregatesFilter<"NotificationQueue"> | string
    attempts?: IntWithAggregatesFilter<"NotificationQueue"> | number
    maxAttempts?: IntWithAggregatesFilter<"NotificationQueue"> | number
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"NotificationQueue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationQueue"> | Date | string
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"NotificationQueue"> | Date | string | null
    batchKey?: StringNullableWithAggregatesFilter<"NotificationQueue"> | string | null
    batchedAt?: DateTimeNullableWithAggregatesFilter<"NotificationQueue"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestCreateNestedManyWithoutRequestorInput
    communityNotes?: OpenNoteCreateNestedManyWithoutAuthorInput
    noteRatings?: NoteRatingCreateNestedManyWithoutRaterInput
    serverMemberships?: ServerMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutRequestorInput
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutAuthorInput
    noteRatings?: NoteRatingUncheckedCreateNestedManyWithoutRaterInput
    serverMemberships?: ServerMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUpdateManyWithoutRequestorNestedInput
    communityNotes?: OpenNoteUpdateManyWithoutAuthorNestedInput
    noteRatings?: NoteRatingUpdateManyWithoutRaterNestedInput
    serverMemberships?: ServerMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutRequestorNestedInput
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutAuthorNestedInput
    noteRatings?: NoteRatingUncheckedUpdateManyWithoutRaterNestedInput
    serverMemberships?: ServerMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServerCreateInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    messages?: MessageCreateNestedManyWithoutServerInput
    serverMembers?: ServerMemberCreateNestedManyWithoutServerInput
    auditLogs?: AuditLogCreateNestedManyWithoutServerInput
  }

  export type ServerUncheckedCreateInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutServerInput
    serverMembers?: ServerMemberUncheckedCreateNestedManyWithoutServerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutServerInput
  }

  export type ServerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUpdateManyWithoutServerNestedInput
    serverMembers?: ServerMemberUpdateManyWithoutServerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutServerNestedInput
  }

  export type ServerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutServerNestedInput
    serverMembers?: ServerMemberUncheckedUpdateManyWithoutServerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutServerNestedInput
  }

  export type ServerCreateManyInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
  }

  export type ServerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServerMemberCreateInput = {
    id?: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutServerMembershipsInput
    server: ServerCreateNestedOneWithoutServerMembersInput
  }

  export type ServerMemberUncheckedCreateInput = {
    id?: string
    userId: string
    serverId: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
  }

  export type ServerMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServerMembershipsNestedInput
    server?: ServerUpdateOneRequiredWithoutServerMembersNestedInput
  }

  export type ServerMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerMemberCreateManyInput = {
    id?: string
    userId: string
    serverId: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
  }

  export type ServerMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    discordId: string
    channelId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    server: ServerCreateNestedOneWithoutMessagesInput
    noteRequests?: NoteRequestCreateNestedManyWithoutMessageInput
    communityNotes?: OpenNoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    discordId: string
    channelId: string
    serverId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutMessageInput
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    server?: ServerUpdateOneRequiredWithoutMessagesNestedInput
    noteRequests?: NoteRequestUpdateManyWithoutMessageNestedInput
    communityNotes?: OpenNoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutMessageNestedInput
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    discordId: string
    channelId: string
    serverId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteRequestCreateInput = {
    id?: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
    message: MessageCreateNestedOneWithoutNoteRequestsInput
    requestor: UserCreateNestedOneWithoutNoteRequestsInput
  }

  export type NoteRequestUncheckedCreateInput = {
    id?: string
    messageId: string
    requestorId: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
  }

  export type NoteRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    message?: MessageUpdateOneRequiredWithoutNoteRequestsNestedInput
    requestor?: UserUpdateOneRequiredWithoutNoteRequestsNestedInput
  }

  export type NoteRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    requestorId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteRequestCreateManyInput = {
    id?: string
    messageId: string
    requestorId: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
  }

  export type NoteRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    requestorId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpenNoteCreateInput = {
    id?: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    message: MessageCreateNestedOneWithoutCommunityNotesInput
    author: UserCreateNestedOneWithoutCommunityNotesInput
    ratings?: NoteRatingCreateNestedManyWithoutNoteInput
  }

  export type OpenNoteUncheckedCreateInput = {
    id?: string
    messageId: string
    authorId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    ratings?: NoteRatingUncheckedCreateNestedManyWithoutNoteInput
  }

  export type OpenNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    message?: MessageUpdateOneRequiredWithoutCommunityNotesNestedInput
    author?: UserUpdateOneRequiredWithoutCommunityNotesNestedInput
    ratings?: NoteRatingUpdateManyWithoutNoteNestedInput
  }

  export type OpenNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    ratings?: NoteRatingUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type OpenNoteCreateManyInput = {
    id?: string
    messageId: string
    authorId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
  }

  export type OpenNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type OpenNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingCreateInput = {
    id?: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
    note: OpenNoteCreateNestedOneWithoutRatingsInput
    rater: UserCreateNestedOneWithoutNoteRatingsInput
  }

  export type NoteRatingUncheckedCreateInput = {
    id?: string
    noteId: string
    raterId: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
  }

  export type NoteRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    note?: OpenNoteUpdateOneRequiredWithoutRatingsNestedInput
    rater?: UserUpdateOneRequiredWithoutNoteRatingsNestedInput
  }

  export type NoteRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingCreateManyInput = {
    id?: string
    noteId: string
    raterId: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
  }

  export type NoteRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type RequestAggregationCreateInput = {
    id?: string
    messageId: string
    totalRequests?: number
    uniqueRequestors?: number
    firstRequestAt?: Date | string | null
    lastRequestAt?: Date | string | null
    thresholdMet?: boolean
    thresholdMetAt?: Date | string | null
    contributorsNotified?: boolean
    notifiedAt?: Date | string | null
  }

  export type RequestAggregationUncheckedCreateInput = {
    id?: string
    messageId: string
    totalRequests?: number
    uniqueRequestors?: number
    firstRequestAt?: Date | string | null
    lastRequestAt?: Date | string | null
    thresholdMet?: boolean
    thresholdMetAt?: Date | string | null
    contributorsNotified?: boolean
    notifiedAt?: Date | string | null
  }

  export type RequestAggregationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    firstRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thresholdMet?: BoolFieldUpdateOperationsInput | boolean
    thresholdMetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contributorsNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestAggregationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    firstRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thresholdMet?: BoolFieldUpdateOperationsInput | boolean
    thresholdMetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contributorsNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestAggregationCreateManyInput = {
    id?: string
    messageId: string
    totalRequests?: number
    uniqueRequestors?: number
    firstRequestAt?: Date | string | null
    lastRequestAt?: Date | string | null
    thresholdMet?: boolean
    thresholdMetAt?: Date | string | null
    contributorsNotified?: boolean
    notifiedAt?: Date | string | null
  }

  export type RequestAggregationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    firstRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thresholdMet?: BoolFieldUpdateOperationsInput | boolean
    thresholdMetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contributorsNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequestAggregationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    firstRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thresholdMet?: BoolFieldUpdateOperationsInput | boolean
    thresholdMetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contributorsNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RateLimitingCreateInput = {
    id?: string
    userId: string
    limitType: string
    count?: number
    resetAt: Date | string
    createdAt?: Date | string
  }

  export type RateLimitingUncheckedCreateInput = {
    id?: string
    userId: string
    limitType: string
    count?: number
    resetAt: Date | string
    createdAt?: Date | string
  }

  export type RateLimitingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitingCreateManyInput = {
    id?: string
    userId: string
    limitType: string
    count?: number
    resetAt: Date | string
    createdAt?: Date | string
  }

  export type RateLimitingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    limitType?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    adminId: string
    action: string
    target?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    server: ServerCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    serverId: string
    adminId: string
    action: string
    target?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    server?: ServerUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    serverId: string
    adminId: string
    action: string
    target?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationQueueCreateInput = {
    id?: string
    serverId: string
    itemType: string
    itemId: string
    flagType: string
    flaggedBy: string
    reason?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type ModerationQueueUncheckedCreateInput = {
    id?: string
    serverId: string
    itemType: string
    itemId: string
    flagType: string
    flaggedBy: string
    reason?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type ModerationQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationQueueCreateManyInput = {
    id?: string
    serverId: string
    itemType: string
    itemId: string
    flagType: string
    flaggedBy: string
    reason?: string | null
    status?: string
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type ModerationQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    flaggedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationQueueCreateInput = {
    id?: string
    userId: string
    type: string
    priority?: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    attempts?: number
    maxAttempts?: number
    scheduledFor?: Date | string | null
    createdAt?: Date | string
    lastAttemptAt?: Date | string | null
    batchKey?: string | null
    batchedAt?: Date | string | null
  }

  export type NotificationQueueUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    priority?: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    attempts?: number
    maxAttempts?: number
    scheduledFor?: Date | string | null
    createdAt?: Date | string
    lastAttemptAt?: Date | string | null
    batchKey?: string | null
    batchedAt?: Date | string | null
  }

  export type NotificationQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchKey?: NullableStringFieldUpdateOperationsInput | string | null
    batchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchKey?: NullableStringFieldUpdateOperationsInput | string | null
    batchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueCreateManyInput = {
    id?: string
    userId: string
    type: string
    priority?: number
    data: JsonNullValueInput | InputJsonValue
    status?: string
    attempts?: number
    maxAttempts?: number
    scheduledFor?: Date | string | null
    createdAt?: Date | string
    lastAttemptAt?: Date | string | null
    batchKey?: string | null
    batchedAt?: Date | string | null
  }

  export type NotificationQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchKey?: NullableStringFieldUpdateOperationsInput | string | null
    batchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchKey?: NullableStringFieldUpdateOperationsInput | string | null
    batchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type NoteRequestListRelationFilter = {
    every?: NoteRequestWhereInput
    some?: NoteRequestWhereInput
    none?: NoteRequestWhereInput
  }

  export type OpenNoteListRelationFilter = {
    every?: OpenNoteWhereInput
    some?: OpenNoteWhereInput
    none?: OpenNoteWhereInput
  }

  export type NoteRatingListRelationFilter = {
    every?: NoteRatingWhereInput
    some?: NoteRatingWhereInput
    none?: NoteRatingWhereInput
  }

  export type ServerMemberListRelationFilter = {
    every?: ServerMemberWhereInput
    some?: ServerMemberWhereInput
    none?: ServerMemberWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NoteRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpenNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServerMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    discriminator?: SortOrder
    avatar?: SortOrder
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    dailyRequestCount?: SortOrder
    lastRequestDate?: SortOrder
    verifiedAt?: SortOrder
    trustLevel?: SortOrder
    notifyNewRequests?: SortOrder
    notifyNotePublished?: SortOrder
    notifyNoteRatings?: SortOrder
    notifyStatusChanged?: SortOrder
    notifyMilestones?: SortOrder
    notificationBatching?: SortOrder
    batchingInterval?: SortOrder
    notificationMethods?: SortOrder
    notificationsMutedUntil?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    dailyRequestCount?: SortOrder
    batchingInterval?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    discriminator?: SortOrder
    avatar?: SortOrder
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    dailyRequestCount?: SortOrder
    lastRequestDate?: SortOrder
    verifiedAt?: SortOrder
    trustLevel?: SortOrder
    notifyNewRequests?: SortOrder
    notifyNotePublished?: SortOrder
    notifyNoteRatings?: SortOrder
    notifyStatusChanged?: SortOrder
    notifyMilestones?: SortOrder
    notificationBatching?: SortOrder
    batchingInterval?: SortOrder
    notificationsMutedUntil?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    username?: SortOrder
    discriminator?: SortOrder
    avatar?: SortOrder
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    dailyRequestCount?: SortOrder
    lastRequestDate?: SortOrder
    verifiedAt?: SortOrder
    trustLevel?: SortOrder
    notifyNewRequests?: SortOrder
    notifyNotePublished?: SortOrder
    notifyNoteRatings?: SortOrder
    notifyStatusChanged?: SortOrder
    notifyMilestones?: SortOrder
    notificationBatching?: SortOrder
    batchingInterval?: SortOrder
    notificationsMutedUntil?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    helpfulnessScore?: SortOrder
    totalNotes?: SortOrder
    totalRatings?: SortOrder
    dailyRequestCount?: SortOrder
    batchingInterval?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServerCountOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    enabled?: SortOrder
    joinedAt?: SortOrder
    allowNoteRequests?: SortOrder
    allowNoteCreation?: SortOrder
    maxRequestsPerUser?: SortOrder
    requireVerification?: SortOrder
    enabledChannels?: SortOrder
    disabledChannels?: SortOrder
    moderatorRoles?: SortOrder
    contributorRoles?: SortOrder
    isPaused?: SortOrder
    pausedAt?: SortOrder
    pausedBy?: SortOrder
    pauseReason?: SortOrder
  }

  export type ServerAvgOrderByAggregateInput = {
    maxRequestsPerUser?: SortOrder
  }

  export type ServerMaxOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    enabled?: SortOrder
    joinedAt?: SortOrder
    allowNoteRequests?: SortOrder
    allowNoteCreation?: SortOrder
    maxRequestsPerUser?: SortOrder
    requireVerification?: SortOrder
    isPaused?: SortOrder
    pausedAt?: SortOrder
    pausedBy?: SortOrder
    pauseReason?: SortOrder
  }

  export type ServerMinOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    enabled?: SortOrder
    joinedAt?: SortOrder
    allowNoteRequests?: SortOrder
    allowNoteCreation?: SortOrder
    maxRequestsPerUser?: SortOrder
    requireVerification?: SortOrder
    isPaused?: SortOrder
    pausedAt?: SortOrder
    pausedBy?: SortOrder
    pauseReason?: SortOrder
  }

  export type ServerSumOrderByAggregateInput = {
    maxRequestsPerUser?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ServerRelationFilter = {
    is?: ServerWhereInput
    isNot?: ServerWhereInput
  }

  export type ServerMemberUserIdServerIdCompoundUniqueInput = {
    userId: string
    serverId: string
  }

  export type ServerMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serverId?: SortOrder
    roles?: SortOrder
    joinedAt?: SortOrder
  }

  export type ServerMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serverId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ServerMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serverId?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    channelId?: SortOrder
    serverId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    hasActiveNote?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    channelId?: SortOrder
    serverId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    hasActiveNote?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
    channelId?: SortOrder
    serverId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    hasActiveNote?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type NoteRequestMessageIdRequestorIdCompoundUniqueInput = {
    messageId: string
    requestorId: string
  }

  export type NoteRequestCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    requestorId?: SortOrder
    reason?: SortOrder
    sources?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
  }

  export type NoteRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    requestorId?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
  }

  export type NoteRequestMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    requestorId?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
  }

  export type OpenNoteCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    classification?: SortOrder
    sources?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastStatusAt?: SortOrder
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    isVisible?: SortOrder
    visibilityScore?: SortOrder
  }

  export type OpenNoteAvgOrderByAggregateInput = {
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    visibilityScore?: SortOrder
  }

  export type OpenNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    classification?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastStatusAt?: SortOrder
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    isVisible?: SortOrder
    visibilityScore?: SortOrder
  }

  export type OpenNoteMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    classification?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastStatusAt?: SortOrder
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    isVisible?: SortOrder
    visibilityScore?: SortOrder
  }

  export type OpenNoteSumOrderByAggregateInput = {
    helpfulCount?: SortOrder
    notHelpfulCount?: SortOrder
    totalRatings?: SortOrder
    helpfulnessRatio?: SortOrder
    visibilityScore?: SortOrder
  }

  export type OpenNoteRelationFilter = {
    is?: OpenNoteWhereInput
    isNot?: OpenNoteWhereInput
  }

  export type NoteRatingNoteIdRaterIdCompoundUniqueInput = {
    noteId: string
    raterId: string
  }

  export type NoteRatingCountOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    raterId?: SortOrder
    helpful?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
    weight?: SortOrder
  }

  export type NoteRatingAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type NoteRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    raterId?: SortOrder
    helpful?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
    weight?: SortOrder
  }

  export type NoteRatingMinOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    raterId?: SortOrder
    helpful?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
    weight?: SortOrder
  }

  export type NoteRatingSumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type RequestAggregationCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    firstRequestAt?: SortOrder
    lastRequestAt?: SortOrder
    thresholdMet?: SortOrder
    thresholdMetAt?: SortOrder
    contributorsNotified?: SortOrder
    notifiedAt?: SortOrder
  }

  export type RequestAggregationAvgOrderByAggregateInput = {
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
  }

  export type RequestAggregationMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    firstRequestAt?: SortOrder
    lastRequestAt?: SortOrder
    thresholdMet?: SortOrder
    thresholdMetAt?: SortOrder
    contributorsNotified?: SortOrder
    notifiedAt?: SortOrder
  }

  export type RequestAggregationMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
    firstRequestAt?: SortOrder
    lastRequestAt?: SortOrder
    thresholdMet?: SortOrder
    thresholdMetAt?: SortOrder
    contributorsNotified?: SortOrder
    notifiedAt?: SortOrder
  }

  export type RequestAggregationSumOrderByAggregateInput = {
    totalRequests?: SortOrder
    uniqueRequestors?: SortOrder
  }

  export type RateLimitingUserIdLimitTypeCompoundUniqueInput = {
    userId: string
    limitType: string
  }

  export type RateLimitingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limitType?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitingAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type RateLimitingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limitType?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    limitType?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitingSumOrderByAggregateInput = {
    count?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    serverId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    serverId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    serverId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    timestamp?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ModerationQueueCountOrderByAggregateInput = {
    id?: SortOrder
    serverId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    flagType?: SortOrder
    flaggedBy?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type ModerationQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    serverId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    flagType?: SortOrder
    flaggedBy?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type ModerationQueueMinOrderByAggregateInput = {
    id?: SortOrder
    serverId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    flagType?: SortOrder
    flaggedBy?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationQueueCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    data?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    lastAttemptAt?: SortOrder
    batchKey?: SortOrder
    batchedAt?: SortOrder
  }

  export type NotificationQueueAvgOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type NotificationQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    lastAttemptAt?: SortOrder
    batchKey?: SortOrder
    batchedAt?: SortOrder
  }

  export type NotificationQueueMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    lastAttemptAt?: SortOrder
    batchKey?: SortOrder
    batchedAt?: SortOrder
  }

  export type NotificationQueueSumOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserCreatenotificationMethodsInput = {
    set: string[]
  }

  export type NoteRequestCreateNestedManyWithoutRequestorInput = {
    create?: XOR<NoteRequestCreateWithoutRequestorInput, NoteRequestUncheckedCreateWithoutRequestorInput> | NoteRequestCreateWithoutRequestorInput[] | NoteRequestUncheckedCreateWithoutRequestorInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutRequestorInput | NoteRequestCreateOrConnectWithoutRequestorInput[]
    createMany?: NoteRequestCreateManyRequestorInputEnvelope
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
  }

  export type OpenNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<OpenNoteCreateWithoutAuthorInput, OpenNoteUncheckedCreateWithoutAuthorInput> | OpenNoteCreateWithoutAuthorInput[] | OpenNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutAuthorInput | OpenNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: OpenNoteCreateManyAuthorInputEnvelope
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
  }

  export type NoteRatingCreateNestedManyWithoutRaterInput = {
    create?: XOR<NoteRatingCreateWithoutRaterInput, NoteRatingUncheckedCreateWithoutRaterInput> | NoteRatingCreateWithoutRaterInput[] | NoteRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutRaterInput | NoteRatingCreateOrConnectWithoutRaterInput[]
    createMany?: NoteRatingCreateManyRaterInputEnvelope
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
  }

  export type ServerMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ServerMemberCreateWithoutUserInput, ServerMemberUncheckedCreateWithoutUserInput> | ServerMemberCreateWithoutUserInput[] | ServerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutUserInput | ServerMemberCreateOrConnectWithoutUserInput[]
    createMany?: ServerMemberCreateManyUserInputEnvelope
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
  }

  export type NoteRequestUncheckedCreateNestedManyWithoutRequestorInput = {
    create?: XOR<NoteRequestCreateWithoutRequestorInput, NoteRequestUncheckedCreateWithoutRequestorInput> | NoteRequestCreateWithoutRequestorInput[] | NoteRequestUncheckedCreateWithoutRequestorInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutRequestorInput | NoteRequestCreateOrConnectWithoutRequestorInput[]
    createMany?: NoteRequestCreateManyRequestorInputEnvelope
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
  }

  export type OpenNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<OpenNoteCreateWithoutAuthorInput, OpenNoteUncheckedCreateWithoutAuthorInput> | OpenNoteCreateWithoutAuthorInput[] | OpenNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutAuthorInput | OpenNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: OpenNoteCreateManyAuthorInputEnvelope
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
  }

  export type NoteRatingUncheckedCreateNestedManyWithoutRaterInput = {
    create?: XOR<NoteRatingCreateWithoutRaterInput, NoteRatingUncheckedCreateWithoutRaterInput> | NoteRatingCreateWithoutRaterInput[] | NoteRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutRaterInput | NoteRatingCreateOrConnectWithoutRaterInput[]
    createMany?: NoteRatingCreateManyRaterInputEnvelope
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
  }

  export type ServerMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServerMemberCreateWithoutUserInput, ServerMemberUncheckedCreateWithoutUserInput> | ServerMemberCreateWithoutUserInput[] | ServerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutUserInput | ServerMemberCreateOrConnectWithoutUserInput[]
    createMany?: ServerMemberCreateManyUserInputEnvelope
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdatenotificationMethodsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NoteRequestUpdateManyWithoutRequestorNestedInput = {
    create?: XOR<NoteRequestCreateWithoutRequestorInput, NoteRequestUncheckedCreateWithoutRequestorInput> | NoteRequestCreateWithoutRequestorInput[] | NoteRequestUncheckedCreateWithoutRequestorInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutRequestorInput | NoteRequestCreateOrConnectWithoutRequestorInput[]
    upsert?: NoteRequestUpsertWithWhereUniqueWithoutRequestorInput | NoteRequestUpsertWithWhereUniqueWithoutRequestorInput[]
    createMany?: NoteRequestCreateManyRequestorInputEnvelope
    set?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    disconnect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    delete?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    update?: NoteRequestUpdateWithWhereUniqueWithoutRequestorInput | NoteRequestUpdateWithWhereUniqueWithoutRequestorInput[]
    updateMany?: NoteRequestUpdateManyWithWhereWithoutRequestorInput | NoteRequestUpdateManyWithWhereWithoutRequestorInput[]
    deleteMany?: NoteRequestScalarWhereInput | NoteRequestScalarWhereInput[]
  }

  export type OpenNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<OpenNoteCreateWithoutAuthorInput, OpenNoteUncheckedCreateWithoutAuthorInput> | OpenNoteCreateWithoutAuthorInput[] | OpenNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutAuthorInput | OpenNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: OpenNoteUpsertWithWhereUniqueWithoutAuthorInput | OpenNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: OpenNoteCreateManyAuthorInputEnvelope
    set?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    disconnect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    delete?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    update?: OpenNoteUpdateWithWhereUniqueWithoutAuthorInput | OpenNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: OpenNoteUpdateManyWithWhereWithoutAuthorInput | OpenNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: OpenNoteScalarWhereInput | OpenNoteScalarWhereInput[]
  }

  export type NoteRatingUpdateManyWithoutRaterNestedInput = {
    create?: XOR<NoteRatingCreateWithoutRaterInput, NoteRatingUncheckedCreateWithoutRaterInput> | NoteRatingCreateWithoutRaterInput[] | NoteRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutRaterInput | NoteRatingCreateOrConnectWithoutRaterInput[]
    upsert?: NoteRatingUpsertWithWhereUniqueWithoutRaterInput | NoteRatingUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: NoteRatingCreateManyRaterInputEnvelope
    set?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    disconnect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    delete?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    update?: NoteRatingUpdateWithWhereUniqueWithoutRaterInput | NoteRatingUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: NoteRatingUpdateManyWithWhereWithoutRaterInput | NoteRatingUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: NoteRatingScalarWhereInput | NoteRatingScalarWhereInput[]
  }

  export type ServerMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServerMemberCreateWithoutUserInput, ServerMemberUncheckedCreateWithoutUserInput> | ServerMemberCreateWithoutUserInput[] | ServerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutUserInput | ServerMemberCreateOrConnectWithoutUserInput[]
    upsert?: ServerMemberUpsertWithWhereUniqueWithoutUserInput | ServerMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServerMemberCreateManyUserInputEnvelope
    set?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    disconnect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    delete?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    update?: ServerMemberUpdateWithWhereUniqueWithoutUserInput | ServerMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServerMemberUpdateManyWithWhereWithoutUserInput | ServerMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServerMemberScalarWhereInput | ServerMemberScalarWhereInput[]
  }

  export type NoteRequestUncheckedUpdateManyWithoutRequestorNestedInput = {
    create?: XOR<NoteRequestCreateWithoutRequestorInput, NoteRequestUncheckedCreateWithoutRequestorInput> | NoteRequestCreateWithoutRequestorInput[] | NoteRequestUncheckedCreateWithoutRequestorInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutRequestorInput | NoteRequestCreateOrConnectWithoutRequestorInput[]
    upsert?: NoteRequestUpsertWithWhereUniqueWithoutRequestorInput | NoteRequestUpsertWithWhereUniqueWithoutRequestorInput[]
    createMany?: NoteRequestCreateManyRequestorInputEnvelope
    set?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    disconnect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    delete?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    update?: NoteRequestUpdateWithWhereUniqueWithoutRequestorInput | NoteRequestUpdateWithWhereUniqueWithoutRequestorInput[]
    updateMany?: NoteRequestUpdateManyWithWhereWithoutRequestorInput | NoteRequestUpdateManyWithWhereWithoutRequestorInput[]
    deleteMany?: NoteRequestScalarWhereInput | NoteRequestScalarWhereInput[]
  }

  export type OpenNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<OpenNoteCreateWithoutAuthorInput, OpenNoteUncheckedCreateWithoutAuthorInput> | OpenNoteCreateWithoutAuthorInput[] | OpenNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutAuthorInput | OpenNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: OpenNoteUpsertWithWhereUniqueWithoutAuthorInput | OpenNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: OpenNoteCreateManyAuthorInputEnvelope
    set?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    disconnect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    delete?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    update?: OpenNoteUpdateWithWhereUniqueWithoutAuthorInput | OpenNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: OpenNoteUpdateManyWithWhereWithoutAuthorInput | OpenNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: OpenNoteScalarWhereInput | OpenNoteScalarWhereInput[]
  }

  export type NoteRatingUncheckedUpdateManyWithoutRaterNestedInput = {
    create?: XOR<NoteRatingCreateWithoutRaterInput, NoteRatingUncheckedCreateWithoutRaterInput> | NoteRatingCreateWithoutRaterInput[] | NoteRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutRaterInput | NoteRatingCreateOrConnectWithoutRaterInput[]
    upsert?: NoteRatingUpsertWithWhereUniqueWithoutRaterInput | NoteRatingUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: NoteRatingCreateManyRaterInputEnvelope
    set?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    disconnect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    delete?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    update?: NoteRatingUpdateWithWhereUniqueWithoutRaterInput | NoteRatingUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: NoteRatingUpdateManyWithWhereWithoutRaterInput | NoteRatingUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: NoteRatingScalarWhereInput | NoteRatingScalarWhereInput[]
  }

  export type ServerMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServerMemberCreateWithoutUserInput, ServerMemberUncheckedCreateWithoutUserInput> | ServerMemberCreateWithoutUserInput[] | ServerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutUserInput | ServerMemberCreateOrConnectWithoutUserInput[]
    upsert?: ServerMemberUpsertWithWhereUniqueWithoutUserInput | ServerMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServerMemberCreateManyUserInputEnvelope
    set?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    disconnect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    delete?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    update?: ServerMemberUpdateWithWhereUniqueWithoutUserInput | ServerMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServerMemberUpdateManyWithWhereWithoutUserInput | ServerMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServerMemberScalarWhereInput | ServerMemberScalarWhereInput[]
  }

  export type ServerCreateenabledChannelsInput = {
    set: string[]
  }

  export type ServerCreatedisabledChannelsInput = {
    set: string[]
  }

  export type ServerCreatemoderatorRolesInput = {
    set: string[]
  }

  export type ServerCreatecontributorRolesInput = {
    set: string[]
  }

  export type MessageCreateNestedManyWithoutServerInput = {
    create?: XOR<MessageCreateWithoutServerInput, MessageUncheckedCreateWithoutServerInput> | MessageCreateWithoutServerInput[] | MessageUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutServerInput | MessageCreateOrConnectWithoutServerInput[]
    createMany?: MessageCreateManyServerInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ServerMemberCreateNestedManyWithoutServerInput = {
    create?: XOR<ServerMemberCreateWithoutServerInput, ServerMemberUncheckedCreateWithoutServerInput> | ServerMemberCreateWithoutServerInput[] | ServerMemberUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutServerInput | ServerMemberCreateOrConnectWithoutServerInput[]
    createMany?: ServerMemberCreateManyServerInputEnvelope
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutServerInput = {
    create?: XOR<AuditLogCreateWithoutServerInput, AuditLogUncheckedCreateWithoutServerInput> | AuditLogCreateWithoutServerInput[] | AuditLogUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutServerInput | AuditLogCreateOrConnectWithoutServerInput[]
    createMany?: AuditLogCreateManyServerInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<MessageCreateWithoutServerInput, MessageUncheckedCreateWithoutServerInput> | MessageCreateWithoutServerInput[] | MessageUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutServerInput | MessageCreateOrConnectWithoutServerInput[]
    createMany?: MessageCreateManyServerInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ServerMemberUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<ServerMemberCreateWithoutServerInput, ServerMemberUncheckedCreateWithoutServerInput> | ServerMemberCreateWithoutServerInput[] | ServerMemberUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutServerInput | ServerMemberCreateOrConnectWithoutServerInput[]
    createMany?: ServerMemberCreateManyServerInputEnvelope
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<AuditLogCreateWithoutServerInput, AuditLogUncheckedCreateWithoutServerInput> | AuditLogCreateWithoutServerInput[] | AuditLogUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutServerInput | AuditLogCreateOrConnectWithoutServerInput[]
    createMany?: AuditLogCreateManyServerInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ServerUpdateenabledChannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ServerUpdatedisabledChannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ServerUpdatemoderatorRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ServerUpdatecontributorRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MessageUpdateManyWithoutServerNestedInput = {
    create?: XOR<MessageCreateWithoutServerInput, MessageUncheckedCreateWithoutServerInput> | MessageCreateWithoutServerInput[] | MessageUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutServerInput | MessageCreateOrConnectWithoutServerInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutServerInput | MessageUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: MessageCreateManyServerInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutServerInput | MessageUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutServerInput | MessageUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ServerMemberUpdateManyWithoutServerNestedInput = {
    create?: XOR<ServerMemberCreateWithoutServerInput, ServerMemberUncheckedCreateWithoutServerInput> | ServerMemberCreateWithoutServerInput[] | ServerMemberUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutServerInput | ServerMemberCreateOrConnectWithoutServerInput[]
    upsert?: ServerMemberUpsertWithWhereUniqueWithoutServerInput | ServerMemberUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: ServerMemberCreateManyServerInputEnvelope
    set?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    disconnect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    delete?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    update?: ServerMemberUpdateWithWhereUniqueWithoutServerInput | ServerMemberUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: ServerMemberUpdateManyWithWhereWithoutServerInput | ServerMemberUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: ServerMemberScalarWhereInput | ServerMemberScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutServerNestedInput = {
    create?: XOR<AuditLogCreateWithoutServerInput, AuditLogUncheckedCreateWithoutServerInput> | AuditLogCreateWithoutServerInput[] | AuditLogUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutServerInput | AuditLogCreateOrConnectWithoutServerInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutServerInput | AuditLogUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: AuditLogCreateManyServerInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutServerInput | AuditLogUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutServerInput | AuditLogUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<MessageCreateWithoutServerInput, MessageUncheckedCreateWithoutServerInput> | MessageCreateWithoutServerInput[] | MessageUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutServerInput | MessageCreateOrConnectWithoutServerInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutServerInput | MessageUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: MessageCreateManyServerInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutServerInput | MessageUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutServerInput | MessageUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ServerMemberUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<ServerMemberCreateWithoutServerInput, ServerMemberUncheckedCreateWithoutServerInput> | ServerMemberCreateWithoutServerInput[] | ServerMemberUncheckedCreateWithoutServerInput[]
    connectOrCreate?: ServerMemberCreateOrConnectWithoutServerInput | ServerMemberCreateOrConnectWithoutServerInput[]
    upsert?: ServerMemberUpsertWithWhereUniqueWithoutServerInput | ServerMemberUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: ServerMemberCreateManyServerInputEnvelope
    set?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    disconnect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    delete?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    connect?: ServerMemberWhereUniqueInput | ServerMemberWhereUniqueInput[]
    update?: ServerMemberUpdateWithWhereUniqueWithoutServerInput | ServerMemberUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: ServerMemberUpdateManyWithWhereWithoutServerInput | ServerMemberUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: ServerMemberScalarWhereInput | ServerMemberScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<AuditLogCreateWithoutServerInput, AuditLogUncheckedCreateWithoutServerInput> | AuditLogCreateWithoutServerInput[] | AuditLogUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutServerInput | AuditLogCreateOrConnectWithoutServerInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutServerInput | AuditLogUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: AuditLogCreateManyServerInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutServerInput | AuditLogUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutServerInput | AuditLogUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ServerMemberCreaterolesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutServerMembershipsInput = {
    create?: XOR<UserCreateWithoutServerMembershipsInput, UserUncheckedCreateWithoutServerMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServerMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ServerCreateNestedOneWithoutServerMembersInput = {
    create?: XOR<ServerCreateWithoutServerMembersInput, ServerUncheckedCreateWithoutServerMembersInput>
    connectOrCreate?: ServerCreateOrConnectWithoutServerMembersInput
    connect?: ServerWhereUniqueInput
  }

  export type ServerMemberUpdaterolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutServerMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutServerMembershipsInput, UserUncheckedCreateWithoutServerMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServerMembershipsInput
    upsert?: UserUpsertWithoutServerMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServerMembershipsInput, UserUpdateWithoutServerMembershipsInput>, UserUncheckedUpdateWithoutServerMembershipsInput>
  }

  export type ServerUpdateOneRequiredWithoutServerMembersNestedInput = {
    create?: XOR<ServerCreateWithoutServerMembersInput, ServerUncheckedCreateWithoutServerMembersInput>
    connectOrCreate?: ServerCreateOrConnectWithoutServerMembersInput
    upsert?: ServerUpsertWithoutServerMembersInput
    connect?: ServerWhereUniqueInput
    update?: XOR<XOR<ServerUpdateToOneWithWhereWithoutServerMembersInput, ServerUpdateWithoutServerMembersInput>, ServerUncheckedUpdateWithoutServerMembersInput>
  }

  export type MessageCreateattachmentsInput = {
    set: string[]
  }

  export type ServerCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ServerCreateWithoutMessagesInput, ServerUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ServerCreateOrConnectWithoutMessagesInput
    connect?: ServerWhereUniqueInput
  }

  export type NoteRequestCreateNestedManyWithoutMessageInput = {
    create?: XOR<NoteRequestCreateWithoutMessageInput, NoteRequestUncheckedCreateWithoutMessageInput> | NoteRequestCreateWithoutMessageInput[] | NoteRequestUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutMessageInput | NoteRequestCreateOrConnectWithoutMessageInput[]
    createMany?: NoteRequestCreateManyMessageInputEnvelope
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
  }

  export type OpenNoteCreateNestedManyWithoutMessageInput = {
    create?: XOR<OpenNoteCreateWithoutMessageInput, OpenNoteUncheckedCreateWithoutMessageInput> | OpenNoteCreateWithoutMessageInput[] | OpenNoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutMessageInput | OpenNoteCreateOrConnectWithoutMessageInput[]
    createMany?: OpenNoteCreateManyMessageInputEnvelope
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
  }

  export type NoteRequestUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<NoteRequestCreateWithoutMessageInput, NoteRequestUncheckedCreateWithoutMessageInput> | NoteRequestCreateWithoutMessageInput[] | NoteRequestUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutMessageInput | NoteRequestCreateOrConnectWithoutMessageInput[]
    createMany?: NoteRequestCreateManyMessageInputEnvelope
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
  }

  export type OpenNoteUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<OpenNoteCreateWithoutMessageInput, OpenNoteUncheckedCreateWithoutMessageInput> | OpenNoteCreateWithoutMessageInput[] | OpenNoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutMessageInput | OpenNoteCreateOrConnectWithoutMessageInput[]
    createMany?: OpenNoteCreateManyMessageInputEnvelope
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
  }

  export type MessageUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ServerUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ServerCreateWithoutMessagesInput, ServerUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ServerCreateOrConnectWithoutMessagesInput
    upsert?: ServerUpsertWithoutMessagesInput
    connect?: ServerWhereUniqueInput
    update?: XOR<XOR<ServerUpdateToOneWithWhereWithoutMessagesInput, ServerUpdateWithoutMessagesInput>, ServerUncheckedUpdateWithoutMessagesInput>
  }

  export type NoteRequestUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NoteRequestCreateWithoutMessageInput, NoteRequestUncheckedCreateWithoutMessageInput> | NoteRequestCreateWithoutMessageInput[] | NoteRequestUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutMessageInput | NoteRequestCreateOrConnectWithoutMessageInput[]
    upsert?: NoteRequestUpsertWithWhereUniqueWithoutMessageInput | NoteRequestUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NoteRequestCreateManyMessageInputEnvelope
    set?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    disconnect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    delete?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    update?: NoteRequestUpdateWithWhereUniqueWithoutMessageInput | NoteRequestUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NoteRequestUpdateManyWithWhereWithoutMessageInput | NoteRequestUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NoteRequestScalarWhereInput | NoteRequestScalarWhereInput[]
  }

  export type OpenNoteUpdateManyWithoutMessageNestedInput = {
    create?: XOR<OpenNoteCreateWithoutMessageInput, OpenNoteUncheckedCreateWithoutMessageInput> | OpenNoteCreateWithoutMessageInput[] | OpenNoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutMessageInput | OpenNoteCreateOrConnectWithoutMessageInput[]
    upsert?: OpenNoteUpsertWithWhereUniqueWithoutMessageInput | OpenNoteUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: OpenNoteCreateManyMessageInputEnvelope
    set?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    disconnect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    delete?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    update?: OpenNoteUpdateWithWhereUniqueWithoutMessageInput | OpenNoteUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: OpenNoteUpdateManyWithWhereWithoutMessageInput | OpenNoteUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: OpenNoteScalarWhereInput | OpenNoteScalarWhereInput[]
  }

  export type NoteRequestUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NoteRequestCreateWithoutMessageInput, NoteRequestUncheckedCreateWithoutMessageInput> | NoteRequestCreateWithoutMessageInput[] | NoteRequestUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NoteRequestCreateOrConnectWithoutMessageInput | NoteRequestCreateOrConnectWithoutMessageInput[]
    upsert?: NoteRequestUpsertWithWhereUniqueWithoutMessageInput | NoteRequestUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NoteRequestCreateManyMessageInputEnvelope
    set?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    disconnect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    delete?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    connect?: NoteRequestWhereUniqueInput | NoteRequestWhereUniqueInput[]
    update?: NoteRequestUpdateWithWhereUniqueWithoutMessageInput | NoteRequestUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NoteRequestUpdateManyWithWhereWithoutMessageInput | NoteRequestUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NoteRequestScalarWhereInput | NoteRequestScalarWhereInput[]
  }

  export type OpenNoteUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<OpenNoteCreateWithoutMessageInput, OpenNoteUncheckedCreateWithoutMessageInput> | OpenNoteCreateWithoutMessageInput[] | OpenNoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: OpenNoteCreateOrConnectWithoutMessageInput | OpenNoteCreateOrConnectWithoutMessageInput[]
    upsert?: OpenNoteUpsertWithWhereUniqueWithoutMessageInput | OpenNoteUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: OpenNoteCreateManyMessageInputEnvelope
    set?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    disconnect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    delete?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    connect?: OpenNoteWhereUniqueInput | OpenNoteWhereUniqueInput[]
    update?: OpenNoteUpdateWithWhereUniqueWithoutMessageInput | OpenNoteUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: OpenNoteUpdateManyWithWhereWithoutMessageInput | OpenNoteUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: OpenNoteScalarWhereInput | OpenNoteScalarWhereInput[]
  }

  export type NoteRequestCreatesourcesInput = {
    set: string[]
  }

  export type MessageCreateNestedOneWithoutNoteRequestsInput = {
    create?: XOR<MessageCreateWithoutNoteRequestsInput, MessageUncheckedCreateWithoutNoteRequestsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNoteRequestsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNoteRequestsInput = {
    create?: XOR<UserCreateWithoutNoteRequestsInput, UserUncheckedCreateWithoutNoteRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type NoteRequestUpdatesourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MessageUpdateOneRequiredWithoutNoteRequestsNestedInput = {
    create?: XOR<MessageCreateWithoutNoteRequestsInput, MessageUncheckedCreateWithoutNoteRequestsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNoteRequestsInput
    upsert?: MessageUpsertWithoutNoteRequestsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutNoteRequestsInput, MessageUpdateWithoutNoteRequestsInput>, MessageUncheckedUpdateWithoutNoteRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutNoteRequestsNestedInput = {
    create?: XOR<UserCreateWithoutNoteRequestsInput, UserUncheckedCreateWithoutNoteRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteRequestsInput
    upsert?: UserUpsertWithoutNoteRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteRequestsInput, UserUpdateWithoutNoteRequestsInput>, UserUncheckedUpdateWithoutNoteRequestsInput>
  }

  export type OpenNoteCreatesourcesInput = {
    set: string[]
  }

  export type MessageCreateNestedOneWithoutCommunityNotesInput = {
    create?: XOR<MessageCreateWithoutCommunityNotesInput, MessageUncheckedCreateWithoutCommunityNotesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutCommunityNotesInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommunityNotesInput = {
    create?: XOR<UserCreateWithoutCommunityNotesInput, UserUncheckedCreateWithoutCommunityNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityNotesInput
    connect?: UserWhereUniqueInput
  }

  export type NoteRatingCreateNestedManyWithoutNoteInput = {
    create?: XOR<NoteRatingCreateWithoutNoteInput, NoteRatingUncheckedCreateWithoutNoteInput> | NoteRatingCreateWithoutNoteInput[] | NoteRatingUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutNoteInput | NoteRatingCreateOrConnectWithoutNoteInput[]
    createMany?: NoteRatingCreateManyNoteInputEnvelope
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
  }

  export type NoteRatingUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<NoteRatingCreateWithoutNoteInput, NoteRatingUncheckedCreateWithoutNoteInput> | NoteRatingCreateWithoutNoteInput[] | NoteRatingUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutNoteInput | NoteRatingCreateOrConnectWithoutNoteInput[]
    createMany?: NoteRatingCreateManyNoteInputEnvelope
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
  }

  export type OpenNoteUpdatesourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MessageUpdateOneRequiredWithoutCommunityNotesNestedInput = {
    create?: XOR<MessageCreateWithoutCommunityNotesInput, MessageUncheckedCreateWithoutCommunityNotesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutCommunityNotesInput
    upsert?: MessageUpsertWithoutCommunityNotesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutCommunityNotesInput, MessageUpdateWithoutCommunityNotesInput>, MessageUncheckedUpdateWithoutCommunityNotesInput>
  }

  export type UserUpdateOneRequiredWithoutCommunityNotesNestedInput = {
    create?: XOR<UserCreateWithoutCommunityNotesInput, UserUncheckedCreateWithoutCommunityNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityNotesInput
    upsert?: UserUpsertWithoutCommunityNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunityNotesInput, UserUpdateWithoutCommunityNotesInput>, UserUncheckedUpdateWithoutCommunityNotesInput>
  }

  export type NoteRatingUpdateManyWithoutNoteNestedInput = {
    create?: XOR<NoteRatingCreateWithoutNoteInput, NoteRatingUncheckedCreateWithoutNoteInput> | NoteRatingCreateWithoutNoteInput[] | NoteRatingUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutNoteInput | NoteRatingCreateOrConnectWithoutNoteInput[]
    upsert?: NoteRatingUpsertWithWhereUniqueWithoutNoteInput | NoteRatingUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: NoteRatingCreateManyNoteInputEnvelope
    set?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    disconnect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    delete?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    update?: NoteRatingUpdateWithWhereUniqueWithoutNoteInput | NoteRatingUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: NoteRatingUpdateManyWithWhereWithoutNoteInput | NoteRatingUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: NoteRatingScalarWhereInput | NoteRatingScalarWhereInput[]
  }

  export type NoteRatingUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<NoteRatingCreateWithoutNoteInput, NoteRatingUncheckedCreateWithoutNoteInput> | NoteRatingCreateWithoutNoteInput[] | NoteRatingUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: NoteRatingCreateOrConnectWithoutNoteInput | NoteRatingCreateOrConnectWithoutNoteInput[]
    upsert?: NoteRatingUpsertWithWhereUniqueWithoutNoteInput | NoteRatingUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: NoteRatingCreateManyNoteInputEnvelope
    set?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    disconnect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    delete?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    connect?: NoteRatingWhereUniqueInput | NoteRatingWhereUniqueInput[]
    update?: NoteRatingUpdateWithWhereUniqueWithoutNoteInput | NoteRatingUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: NoteRatingUpdateManyWithWhereWithoutNoteInput | NoteRatingUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: NoteRatingScalarWhereInput | NoteRatingScalarWhereInput[]
  }

  export type OpenNoteCreateNestedOneWithoutRatingsInput = {
    create?: XOR<OpenNoteCreateWithoutRatingsInput, OpenNoteUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: OpenNoteCreateOrConnectWithoutRatingsInput
    connect?: OpenNoteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNoteRatingsInput = {
    create?: XOR<UserCreateWithoutNoteRatingsInput, UserUncheckedCreateWithoutNoteRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type OpenNoteUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<OpenNoteCreateWithoutRatingsInput, OpenNoteUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: OpenNoteCreateOrConnectWithoutRatingsInput
    upsert?: OpenNoteUpsertWithoutRatingsInput
    connect?: OpenNoteWhereUniqueInput
    update?: XOR<XOR<OpenNoteUpdateToOneWithWhereWithoutRatingsInput, OpenNoteUpdateWithoutRatingsInput>, OpenNoteUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutNoteRatingsNestedInput = {
    create?: XOR<UserCreateWithoutNoteRatingsInput, UserUncheckedCreateWithoutNoteRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteRatingsInput
    upsert?: UserUpsertWithoutNoteRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteRatingsInput, UserUpdateWithoutNoteRatingsInput>, UserUncheckedUpdateWithoutNoteRatingsInput>
  }

  export type ServerCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ServerCreateWithoutAuditLogsInput, ServerUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ServerCreateOrConnectWithoutAuditLogsInput
    connect?: ServerWhereUniqueInput
  }

  export type ServerUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<ServerCreateWithoutAuditLogsInput, ServerUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ServerCreateOrConnectWithoutAuditLogsInput
    upsert?: ServerUpsertWithoutAuditLogsInput
    connect?: ServerWhereUniqueInput
    update?: XOR<XOR<ServerUpdateToOneWithWhereWithoutAuditLogsInput, ServerUpdateWithoutAuditLogsInput>, ServerUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NoteRequestCreateWithoutRequestorInput = {
    id?: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
    message: MessageCreateNestedOneWithoutNoteRequestsInput
  }

  export type NoteRequestUncheckedCreateWithoutRequestorInput = {
    id?: string
    messageId: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
  }

  export type NoteRequestCreateOrConnectWithoutRequestorInput = {
    where: NoteRequestWhereUniqueInput
    create: XOR<NoteRequestCreateWithoutRequestorInput, NoteRequestUncheckedCreateWithoutRequestorInput>
  }

  export type NoteRequestCreateManyRequestorInputEnvelope = {
    data: NoteRequestCreateManyRequestorInput | NoteRequestCreateManyRequestorInput[]
    skipDuplicates?: boolean
  }

  export type OpenNoteCreateWithoutAuthorInput = {
    id?: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    message: MessageCreateNestedOneWithoutCommunityNotesInput
    ratings?: NoteRatingCreateNestedManyWithoutNoteInput
  }

  export type OpenNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    messageId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    ratings?: NoteRatingUncheckedCreateNestedManyWithoutNoteInput
  }

  export type OpenNoteCreateOrConnectWithoutAuthorInput = {
    where: OpenNoteWhereUniqueInput
    create: XOR<OpenNoteCreateWithoutAuthorInput, OpenNoteUncheckedCreateWithoutAuthorInput>
  }

  export type OpenNoteCreateManyAuthorInputEnvelope = {
    data: OpenNoteCreateManyAuthorInput | OpenNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type NoteRatingCreateWithoutRaterInput = {
    id?: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
    note: OpenNoteCreateNestedOneWithoutRatingsInput
  }

  export type NoteRatingUncheckedCreateWithoutRaterInput = {
    id?: string
    noteId: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
  }

  export type NoteRatingCreateOrConnectWithoutRaterInput = {
    where: NoteRatingWhereUniqueInput
    create: XOR<NoteRatingCreateWithoutRaterInput, NoteRatingUncheckedCreateWithoutRaterInput>
  }

  export type NoteRatingCreateManyRaterInputEnvelope = {
    data: NoteRatingCreateManyRaterInput | NoteRatingCreateManyRaterInput[]
    skipDuplicates?: boolean
  }

  export type ServerMemberCreateWithoutUserInput = {
    id?: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
    server: ServerCreateNestedOneWithoutServerMembersInput
  }

  export type ServerMemberUncheckedCreateWithoutUserInput = {
    id?: string
    serverId: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
  }

  export type ServerMemberCreateOrConnectWithoutUserInput = {
    where: ServerMemberWhereUniqueInput
    create: XOR<ServerMemberCreateWithoutUserInput, ServerMemberUncheckedCreateWithoutUserInput>
  }

  export type ServerMemberCreateManyUserInputEnvelope = {
    data: ServerMemberCreateManyUserInput | ServerMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoteRequestUpsertWithWhereUniqueWithoutRequestorInput = {
    where: NoteRequestWhereUniqueInput
    update: XOR<NoteRequestUpdateWithoutRequestorInput, NoteRequestUncheckedUpdateWithoutRequestorInput>
    create: XOR<NoteRequestCreateWithoutRequestorInput, NoteRequestUncheckedCreateWithoutRequestorInput>
  }

  export type NoteRequestUpdateWithWhereUniqueWithoutRequestorInput = {
    where: NoteRequestWhereUniqueInput
    data: XOR<NoteRequestUpdateWithoutRequestorInput, NoteRequestUncheckedUpdateWithoutRequestorInput>
  }

  export type NoteRequestUpdateManyWithWhereWithoutRequestorInput = {
    where: NoteRequestScalarWhereInput
    data: XOR<NoteRequestUpdateManyMutationInput, NoteRequestUncheckedUpdateManyWithoutRequestorInput>
  }

  export type NoteRequestScalarWhereInput = {
    AND?: NoteRequestScalarWhereInput | NoteRequestScalarWhereInput[]
    OR?: NoteRequestScalarWhereInput[]
    NOT?: NoteRequestScalarWhereInput | NoteRequestScalarWhereInput[]
    id?: StringFilter<"NoteRequest"> | string
    messageId?: StringFilter<"NoteRequest"> | string
    requestorId?: StringFilter<"NoteRequest"> | string
    reason?: StringNullableFilter<"NoteRequest"> | string | null
    sources?: StringNullableListFilter<"NoteRequest">
    timestamp?: DateTimeFilter<"NoteRequest"> | Date | string
    isActive?: BoolFilter<"NoteRequest"> | boolean
  }

  export type OpenNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: OpenNoteWhereUniqueInput
    update: XOR<OpenNoteUpdateWithoutAuthorInput, OpenNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<OpenNoteCreateWithoutAuthorInput, OpenNoteUncheckedCreateWithoutAuthorInput>
  }

  export type OpenNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: OpenNoteWhereUniqueInput
    data: XOR<OpenNoteUpdateWithoutAuthorInput, OpenNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type OpenNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: OpenNoteScalarWhereInput
    data: XOR<OpenNoteUpdateManyMutationInput, OpenNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type OpenNoteScalarWhereInput = {
    AND?: OpenNoteScalarWhereInput | OpenNoteScalarWhereInput[]
    OR?: OpenNoteScalarWhereInput[]
    NOT?: OpenNoteScalarWhereInput | OpenNoteScalarWhereInput[]
    id?: StringFilter<"OpenNote"> | string
    messageId?: StringFilter<"OpenNote"> | string
    authorId?: StringFilter<"OpenNote"> | string
    content?: StringFilter<"OpenNote"> | string
    classification?: StringFilter<"OpenNote"> | string
    sources?: StringNullableListFilter<"OpenNote">
    status?: StringFilter<"OpenNote"> | string
    submittedAt?: DateTimeFilter<"OpenNote"> | Date | string
    lastStatusAt?: DateTimeFilter<"OpenNote"> | Date | string
    helpfulCount?: IntFilter<"OpenNote"> | number
    notHelpfulCount?: IntFilter<"OpenNote"> | number
    totalRatings?: IntFilter<"OpenNote"> | number
    helpfulnessRatio?: FloatFilter<"OpenNote"> | number
    isVisible?: BoolFilter<"OpenNote"> | boolean
    visibilityScore?: FloatFilter<"OpenNote"> | number
  }

  export type NoteRatingUpsertWithWhereUniqueWithoutRaterInput = {
    where: NoteRatingWhereUniqueInput
    update: XOR<NoteRatingUpdateWithoutRaterInput, NoteRatingUncheckedUpdateWithoutRaterInput>
    create: XOR<NoteRatingCreateWithoutRaterInput, NoteRatingUncheckedCreateWithoutRaterInput>
  }

  export type NoteRatingUpdateWithWhereUniqueWithoutRaterInput = {
    where: NoteRatingWhereUniqueInput
    data: XOR<NoteRatingUpdateWithoutRaterInput, NoteRatingUncheckedUpdateWithoutRaterInput>
  }

  export type NoteRatingUpdateManyWithWhereWithoutRaterInput = {
    where: NoteRatingScalarWhereInput
    data: XOR<NoteRatingUpdateManyMutationInput, NoteRatingUncheckedUpdateManyWithoutRaterInput>
  }

  export type NoteRatingScalarWhereInput = {
    AND?: NoteRatingScalarWhereInput | NoteRatingScalarWhereInput[]
    OR?: NoteRatingScalarWhereInput[]
    NOT?: NoteRatingScalarWhereInput | NoteRatingScalarWhereInput[]
    id?: StringFilter<"NoteRating"> | string
    noteId?: StringFilter<"NoteRating"> | string
    raterId?: StringFilter<"NoteRating"> | string
    helpful?: BoolFilter<"NoteRating"> | boolean
    reason?: StringNullableFilter<"NoteRating"> | string | null
    timestamp?: DateTimeFilter<"NoteRating"> | Date | string
    weight?: FloatFilter<"NoteRating"> | number
  }

  export type ServerMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ServerMemberWhereUniqueInput
    update: XOR<ServerMemberUpdateWithoutUserInput, ServerMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ServerMemberCreateWithoutUserInput, ServerMemberUncheckedCreateWithoutUserInput>
  }

  export type ServerMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ServerMemberWhereUniqueInput
    data: XOR<ServerMemberUpdateWithoutUserInput, ServerMemberUncheckedUpdateWithoutUserInput>
  }

  export type ServerMemberUpdateManyWithWhereWithoutUserInput = {
    where: ServerMemberScalarWhereInput
    data: XOR<ServerMemberUpdateManyMutationInput, ServerMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ServerMemberScalarWhereInput = {
    AND?: ServerMemberScalarWhereInput | ServerMemberScalarWhereInput[]
    OR?: ServerMemberScalarWhereInput[]
    NOT?: ServerMemberScalarWhereInput | ServerMemberScalarWhereInput[]
    id?: StringFilter<"ServerMember"> | string
    userId?: StringFilter<"ServerMember"> | string
    serverId?: StringFilter<"ServerMember"> | string
    roles?: StringNullableListFilter<"ServerMember">
    joinedAt?: DateTimeFilter<"ServerMember"> | Date | string
  }

  export type MessageCreateWithoutServerInput = {
    id?: string
    discordId: string
    channelId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    noteRequests?: NoteRequestCreateNestedManyWithoutMessageInput
    communityNotes?: OpenNoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutServerInput = {
    id?: string
    discordId: string
    channelId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutMessageInput
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutServerInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutServerInput, MessageUncheckedCreateWithoutServerInput>
  }

  export type MessageCreateManyServerInputEnvelope = {
    data: MessageCreateManyServerInput | MessageCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type ServerMemberCreateWithoutServerInput = {
    id?: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutServerMembershipsInput
  }

  export type ServerMemberUncheckedCreateWithoutServerInput = {
    id?: string
    userId: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
  }

  export type ServerMemberCreateOrConnectWithoutServerInput = {
    where: ServerMemberWhereUniqueInput
    create: XOR<ServerMemberCreateWithoutServerInput, ServerMemberUncheckedCreateWithoutServerInput>
  }

  export type ServerMemberCreateManyServerInputEnvelope = {
    data: ServerMemberCreateManyServerInput | ServerMemberCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutServerInput = {
    id?: string
    adminId: string
    action: string
    target?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutServerInput = {
    id?: string
    adminId: string
    action: string
    target?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutServerInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutServerInput, AuditLogUncheckedCreateWithoutServerInput>
  }

  export type AuditLogCreateManyServerInputEnvelope = {
    data: AuditLogCreateManyServerInput | AuditLogCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutServerInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutServerInput, MessageUncheckedUpdateWithoutServerInput>
    create: XOR<MessageCreateWithoutServerInput, MessageUncheckedCreateWithoutServerInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutServerInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutServerInput, MessageUncheckedUpdateWithoutServerInput>
  }

  export type MessageUpdateManyWithWhereWithoutServerInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutServerInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    discordId?: StringFilter<"Message"> | string
    channelId?: StringFilter<"Message"> | string
    serverId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    timestamp?: DateTimeFilter<"Message"> | Date | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    totalRequests?: IntFilter<"Message"> | number
    uniqueRequestors?: IntFilter<"Message"> | number
    hasActiveNote?: BoolFilter<"Message"> | boolean
  }

  export type ServerMemberUpsertWithWhereUniqueWithoutServerInput = {
    where: ServerMemberWhereUniqueInput
    update: XOR<ServerMemberUpdateWithoutServerInput, ServerMemberUncheckedUpdateWithoutServerInput>
    create: XOR<ServerMemberCreateWithoutServerInput, ServerMemberUncheckedCreateWithoutServerInput>
  }

  export type ServerMemberUpdateWithWhereUniqueWithoutServerInput = {
    where: ServerMemberWhereUniqueInput
    data: XOR<ServerMemberUpdateWithoutServerInput, ServerMemberUncheckedUpdateWithoutServerInput>
  }

  export type ServerMemberUpdateManyWithWhereWithoutServerInput = {
    where: ServerMemberScalarWhereInput
    data: XOR<ServerMemberUpdateManyMutationInput, ServerMemberUncheckedUpdateManyWithoutServerInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutServerInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutServerInput, AuditLogUncheckedUpdateWithoutServerInput>
    create: XOR<AuditLogCreateWithoutServerInput, AuditLogUncheckedCreateWithoutServerInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutServerInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutServerInput, AuditLogUncheckedUpdateWithoutServerInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutServerInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutServerInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    serverId?: StringFilter<"AuditLog"> | string
    adminId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutServerMembershipsInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestCreateNestedManyWithoutRequestorInput
    communityNotes?: OpenNoteCreateNestedManyWithoutAuthorInput
    noteRatings?: NoteRatingCreateNestedManyWithoutRaterInput
  }

  export type UserUncheckedCreateWithoutServerMembershipsInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutRequestorInput
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutAuthorInput
    noteRatings?: NoteRatingUncheckedCreateNestedManyWithoutRaterInput
  }

  export type UserCreateOrConnectWithoutServerMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServerMembershipsInput, UserUncheckedCreateWithoutServerMembershipsInput>
  }

  export type ServerCreateWithoutServerMembersInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    messages?: MessageCreateNestedManyWithoutServerInput
    auditLogs?: AuditLogCreateNestedManyWithoutServerInput
  }

  export type ServerUncheckedCreateWithoutServerMembersInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutServerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutServerInput
  }

  export type ServerCreateOrConnectWithoutServerMembersInput = {
    where: ServerWhereUniqueInput
    create: XOR<ServerCreateWithoutServerMembersInput, ServerUncheckedCreateWithoutServerMembersInput>
  }

  export type UserUpsertWithoutServerMembershipsInput = {
    update: XOR<UserUpdateWithoutServerMembershipsInput, UserUncheckedUpdateWithoutServerMembershipsInput>
    create: XOR<UserCreateWithoutServerMembershipsInput, UserUncheckedCreateWithoutServerMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServerMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServerMembershipsInput, UserUncheckedUpdateWithoutServerMembershipsInput>
  }

  export type UserUpdateWithoutServerMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUpdateManyWithoutRequestorNestedInput
    communityNotes?: OpenNoteUpdateManyWithoutAuthorNestedInput
    noteRatings?: NoteRatingUpdateManyWithoutRaterNestedInput
  }

  export type UserUncheckedUpdateWithoutServerMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutRequestorNestedInput
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutAuthorNestedInput
    noteRatings?: NoteRatingUncheckedUpdateManyWithoutRaterNestedInput
  }

  export type ServerUpsertWithoutServerMembersInput = {
    update: XOR<ServerUpdateWithoutServerMembersInput, ServerUncheckedUpdateWithoutServerMembersInput>
    create: XOR<ServerCreateWithoutServerMembersInput, ServerUncheckedCreateWithoutServerMembersInput>
    where?: ServerWhereInput
  }

  export type ServerUpdateToOneWithWhereWithoutServerMembersInput = {
    where?: ServerWhereInput
    data: XOR<ServerUpdateWithoutServerMembersInput, ServerUncheckedUpdateWithoutServerMembersInput>
  }

  export type ServerUpdateWithoutServerMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUpdateManyWithoutServerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutServerNestedInput
  }

  export type ServerUncheckedUpdateWithoutServerMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutServerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutServerNestedInput
  }

  export type ServerCreateWithoutMessagesInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    serverMembers?: ServerMemberCreateNestedManyWithoutServerInput
    auditLogs?: AuditLogCreateNestedManyWithoutServerInput
  }

  export type ServerUncheckedCreateWithoutMessagesInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    serverMembers?: ServerMemberUncheckedCreateNestedManyWithoutServerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutServerInput
  }

  export type ServerCreateOrConnectWithoutMessagesInput = {
    where: ServerWhereUniqueInput
    create: XOR<ServerCreateWithoutMessagesInput, ServerUncheckedCreateWithoutMessagesInput>
  }

  export type NoteRequestCreateWithoutMessageInput = {
    id?: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
    requestor: UserCreateNestedOneWithoutNoteRequestsInput
  }

  export type NoteRequestUncheckedCreateWithoutMessageInput = {
    id?: string
    requestorId: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
  }

  export type NoteRequestCreateOrConnectWithoutMessageInput = {
    where: NoteRequestWhereUniqueInput
    create: XOR<NoteRequestCreateWithoutMessageInput, NoteRequestUncheckedCreateWithoutMessageInput>
  }

  export type NoteRequestCreateManyMessageInputEnvelope = {
    data: NoteRequestCreateManyMessageInput | NoteRequestCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type OpenNoteCreateWithoutMessageInput = {
    id?: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    author: UserCreateNestedOneWithoutCommunityNotesInput
    ratings?: NoteRatingCreateNestedManyWithoutNoteInput
  }

  export type OpenNoteUncheckedCreateWithoutMessageInput = {
    id?: string
    authorId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    ratings?: NoteRatingUncheckedCreateNestedManyWithoutNoteInput
  }

  export type OpenNoteCreateOrConnectWithoutMessageInput = {
    where: OpenNoteWhereUniqueInput
    create: XOR<OpenNoteCreateWithoutMessageInput, OpenNoteUncheckedCreateWithoutMessageInput>
  }

  export type OpenNoteCreateManyMessageInputEnvelope = {
    data: OpenNoteCreateManyMessageInput | OpenNoteCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ServerUpsertWithoutMessagesInput = {
    update: XOR<ServerUpdateWithoutMessagesInput, ServerUncheckedUpdateWithoutMessagesInput>
    create: XOR<ServerCreateWithoutMessagesInput, ServerUncheckedCreateWithoutMessagesInput>
    where?: ServerWhereInput
  }

  export type ServerUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ServerWhereInput
    data: XOR<ServerUpdateWithoutMessagesInput, ServerUncheckedUpdateWithoutMessagesInput>
  }

  export type ServerUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    serverMembers?: ServerMemberUpdateManyWithoutServerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutServerNestedInput
  }

  export type ServerUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    serverMembers?: ServerMemberUncheckedUpdateManyWithoutServerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutServerNestedInput
  }

  export type NoteRequestUpsertWithWhereUniqueWithoutMessageInput = {
    where: NoteRequestWhereUniqueInput
    update: XOR<NoteRequestUpdateWithoutMessageInput, NoteRequestUncheckedUpdateWithoutMessageInput>
    create: XOR<NoteRequestCreateWithoutMessageInput, NoteRequestUncheckedCreateWithoutMessageInput>
  }

  export type NoteRequestUpdateWithWhereUniqueWithoutMessageInput = {
    where: NoteRequestWhereUniqueInput
    data: XOR<NoteRequestUpdateWithoutMessageInput, NoteRequestUncheckedUpdateWithoutMessageInput>
  }

  export type NoteRequestUpdateManyWithWhereWithoutMessageInput = {
    where: NoteRequestScalarWhereInput
    data: XOR<NoteRequestUpdateManyMutationInput, NoteRequestUncheckedUpdateManyWithoutMessageInput>
  }

  export type OpenNoteUpsertWithWhereUniqueWithoutMessageInput = {
    where: OpenNoteWhereUniqueInput
    update: XOR<OpenNoteUpdateWithoutMessageInput, OpenNoteUncheckedUpdateWithoutMessageInput>
    create: XOR<OpenNoteCreateWithoutMessageInput, OpenNoteUncheckedCreateWithoutMessageInput>
  }

  export type OpenNoteUpdateWithWhereUniqueWithoutMessageInput = {
    where: OpenNoteWhereUniqueInput
    data: XOR<OpenNoteUpdateWithoutMessageInput, OpenNoteUncheckedUpdateWithoutMessageInput>
  }

  export type OpenNoteUpdateManyWithWhereWithoutMessageInput = {
    where: OpenNoteScalarWhereInput
    data: XOR<OpenNoteUpdateManyMutationInput, OpenNoteUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutNoteRequestsInput = {
    id?: string
    discordId: string
    channelId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    server: ServerCreateNestedOneWithoutMessagesInput
    communityNotes?: OpenNoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutNoteRequestsInput = {
    id?: string
    discordId: string
    channelId: string
    serverId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutNoteRequestsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutNoteRequestsInput, MessageUncheckedCreateWithoutNoteRequestsInput>
  }

  export type UserCreateWithoutNoteRequestsInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    communityNotes?: OpenNoteCreateNestedManyWithoutAuthorInput
    noteRatings?: NoteRatingCreateNestedManyWithoutRaterInput
    serverMemberships?: ServerMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoteRequestsInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutAuthorInput
    noteRatings?: NoteRatingUncheckedCreateNestedManyWithoutRaterInput
    serverMemberships?: ServerMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNoteRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteRequestsInput, UserUncheckedCreateWithoutNoteRequestsInput>
  }

  export type MessageUpsertWithoutNoteRequestsInput = {
    update: XOR<MessageUpdateWithoutNoteRequestsInput, MessageUncheckedUpdateWithoutNoteRequestsInput>
    create: XOR<MessageCreateWithoutNoteRequestsInput, MessageUncheckedCreateWithoutNoteRequestsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutNoteRequestsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutNoteRequestsInput, MessageUncheckedUpdateWithoutNoteRequestsInput>
  }

  export type MessageUpdateWithoutNoteRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    server?: ServerUpdateOneRequiredWithoutMessagesNestedInput
    communityNotes?: OpenNoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutNoteRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutNoteRequestsInput = {
    update: XOR<UserUpdateWithoutNoteRequestsInput, UserUncheckedUpdateWithoutNoteRequestsInput>
    create: XOR<UserCreateWithoutNoteRequestsInput, UserUncheckedCreateWithoutNoteRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteRequestsInput, UserUncheckedUpdateWithoutNoteRequestsInput>
  }

  export type UserUpdateWithoutNoteRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityNotes?: OpenNoteUpdateManyWithoutAuthorNestedInput
    noteRatings?: NoteRatingUpdateManyWithoutRaterNestedInput
    serverMemberships?: ServerMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutAuthorNestedInput
    noteRatings?: NoteRatingUncheckedUpdateManyWithoutRaterNestedInput
    serverMemberships?: ServerMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutCommunityNotesInput = {
    id?: string
    discordId: string
    channelId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    server: ServerCreateNestedOneWithoutMessagesInput
    noteRequests?: NoteRequestCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutCommunityNotesInput = {
    id?: string
    discordId: string
    channelId: string
    serverId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutCommunityNotesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCommunityNotesInput, MessageUncheckedCreateWithoutCommunityNotesInput>
  }

  export type UserCreateWithoutCommunityNotesInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestCreateNestedManyWithoutRequestorInput
    noteRatings?: NoteRatingCreateNestedManyWithoutRaterInput
    serverMemberships?: ServerMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityNotesInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutRequestorInput
    noteRatings?: NoteRatingUncheckedCreateNestedManyWithoutRaterInput
    serverMemberships?: ServerMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityNotesInput, UserUncheckedCreateWithoutCommunityNotesInput>
  }

  export type NoteRatingCreateWithoutNoteInput = {
    id?: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
    rater: UserCreateNestedOneWithoutNoteRatingsInput
  }

  export type NoteRatingUncheckedCreateWithoutNoteInput = {
    id?: string
    raterId: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
  }

  export type NoteRatingCreateOrConnectWithoutNoteInput = {
    where: NoteRatingWhereUniqueInput
    create: XOR<NoteRatingCreateWithoutNoteInput, NoteRatingUncheckedCreateWithoutNoteInput>
  }

  export type NoteRatingCreateManyNoteInputEnvelope = {
    data: NoteRatingCreateManyNoteInput | NoteRatingCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithoutCommunityNotesInput = {
    update: XOR<MessageUpdateWithoutCommunityNotesInput, MessageUncheckedUpdateWithoutCommunityNotesInput>
    create: XOR<MessageCreateWithoutCommunityNotesInput, MessageUncheckedCreateWithoutCommunityNotesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutCommunityNotesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutCommunityNotesInput, MessageUncheckedUpdateWithoutCommunityNotesInput>
  }

  export type MessageUpdateWithoutCommunityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    server?: ServerUpdateOneRequiredWithoutMessagesNestedInput
    noteRequests?: NoteRequestUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutCommunityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutCommunityNotesInput = {
    update: XOR<UserUpdateWithoutCommunityNotesInput, UserUncheckedUpdateWithoutCommunityNotesInput>
    create: XOR<UserCreateWithoutCommunityNotesInput, UserUncheckedCreateWithoutCommunityNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunityNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunityNotesInput, UserUncheckedUpdateWithoutCommunityNotesInput>
  }

  export type UserUpdateWithoutCommunityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUpdateManyWithoutRequestorNestedInput
    noteRatings?: NoteRatingUpdateManyWithoutRaterNestedInput
    serverMemberships?: ServerMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutRequestorNestedInput
    noteRatings?: NoteRatingUncheckedUpdateManyWithoutRaterNestedInput
    serverMemberships?: ServerMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NoteRatingUpsertWithWhereUniqueWithoutNoteInput = {
    where: NoteRatingWhereUniqueInput
    update: XOR<NoteRatingUpdateWithoutNoteInput, NoteRatingUncheckedUpdateWithoutNoteInput>
    create: XOR<NoteRatingCreateWithoutNoteInput, NoteRatingUncheckedCreateWithoutNoteInput>
  }

  export type NoteRatingUpdateWithWhereUniqueWithoutNoteInput = {
    where: NoteRatingWhereUniqueInput
    data: XOR<NoteRatingUpdateWithoutNoteInput, NoteRatingUncheckedUpdateWithoutNoteInput>
  }

  export type NoteRatingUpdateManyWithWhereWithoutNoteInput = {
    where: NoteRatingScalarWhereInput
    data: XOR<NoteRatingUpdateManyMutationInput, NoteRatingUncheckedUpdateManyWithoutNoteInput>
  }

  export type OpenNoteCreateWithoutRatingsInput = {
    id?: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
    message: MessageCreateNestedOneWithoutCommunityNotesInput
    author: UserCreateNestedOneWithoutCommunityNotesInput
  }

  export type OpenNoteUncheckedCreateWithoutRatingsInput = {
    id?: string
    messageId: string
    authorId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
  }

  export type OpenNoteCreateOrConnectWithoutRatingsInput = {
    where: OpenNoteWhereUniqueInput
    create: XOR<OpenNoteCreateWithoutRatingsInput, OpenNoteUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutNoteRatingsInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestCreateNestedManyWithoutRequestorInput
    communityNotes?: OpenNoteCreateNestedManyWithoutAuthorInput
    serverMemberships?: ServerMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoteRatingsInput = {
    id?: string
    discordId: string
    username: string
    discriminator?: string | null
    avatar?: string | null
    helpfulnessScore?: number
    totalNotes?: number
    totalRatings?: number
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    dailyRequestCount?: number
    lastRequestDate?: Date | string | null
    verifiedAt?: Date | string | null
    trustLevel?: string
    notifyNewRequests?: boolean
    notifyNotePublished?: boolean
    notifyNoteRatings?: boolean
    notifyStatusChanged?: boolean
    notifyMilestones?: boolean
    notificationBatching?: boolean
    batchingInterval?: number
    notificationMethods?: UserCreatenotificationMethodsInput | string[]
    notificationsMutedUntil?: Date | string | null
    noteRequests?: NoteRequestUncheckedCreateNestedManyWithoutRequestorInput
    communityNotes?: OpenNoteUncheckedCreateNestedManyWithoutAuthorInput
    serverMemberships?: ServerMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNoteRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteRatingsInput, UserUncheckedCreateWithoutNoteRatingsInput>
  }

  export type OpenNoteUpsertWithoutRatingsInput = {
    update: XOR<OpenNoteUpdateWithoutRatingsInput, OpenNoteUncheckedUpdateWithoutRatingsInput>
    create: XOR<OpenNoteCreateWithoutRatingsInput, OpenNoteUncheckedCreateWithoutRatingsInput>
    where?: OpenNoteWhereInput
  }

  export type OpenNoteUpdateToOneWithWhereWithoutRatingsInput = {
    where?: OpenNoteWhereInput
    data: XOR<OpenNoteUpdateWithoutRatingsInput, OpenNoteUncheckedUpdateWithoutRatingsInput>
  }

  export type OpenNoteUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    message?: MessageUpdateOneRequiredWithoutCommunityNotesNestedInput
    author?: UserUpdateOneRequiredWithoutCommunityNotesNestedInput
  }

  export type OpenNoteUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutNoteRatingsInput = {
    update: XOR<UserUpdateWithoutNoteRatingsInput, UserUncheckedUpdateWithoutNoteRatingsInput>
    create: XOR<UserCreateWithoutNoteRatingsInput, UserUncheckedCreateWithoutNoteRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteRatingsInput, UserUncheckedUpdateWithoutNoteRatingsInput>
  }

  export type UserUpdateWithoutNoteRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUpdateManyWithoutRequestorNestedInput
    communityNotes?: OpenNoteUpdateManyWithoutAuthorNestedInput
    serverMemberships?: ServerMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discriminator?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    helpfulnessScore?: FloatFieldUpdateOperationsInput | number
    totalNotes?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyRequestCount?: IntFieldUpdateOperationsInput | number
    lastRequestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trustLevel?: StringFieldUpdateOperationsInput | string
    notifyNewRequests?: BoolFieldUpdateOperationsInput | boolean
    notifyNotePublished?: BoolFieldUpdateOperationsInput | boolean
    notifyNoteRatings?: BoolFieldUpdateOperationsInput | boolean
    notifyStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    notifyMilestones?: BoolFieldUpdateOperationsInput | boolean
    notificationBatching?: BoolFieldUpdateOperationsInput | boolean
    batchingInterval?: IntFieldUpdateOperationsInput | number
    notificationMethods?: UserUpdatenotificationMethodsInput | string[]
    notificationsMutedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutRequestorNestedInput
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutAuthorNestedInput
    serverMemberships?: ServerMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServerCreateWithoutAuditLogsInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    messages?: MessageCreateNestedManyWithoutServerInput
    serverMembers?: ServerMemberCreateNestedManyWithoutServerInput
  }

  export type ServerUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    discordId: string
    name: string
    icon?: string | null
    enabled?: boolean
    joinedAt?: Date | string
    allowNoteRequests?: boolean
    allowNoteCreation?: boolean
    maxRequestsPerUser?: number
    requireVerification?: boolean
    enabledChannels?: ServerCreateenabledChannelsInput | string[]
    disabledChannels?: ServerCreatedisabledChannelsInput | string[]
    moderatorRoles?: ServerCreatemoderatorRolesInput | string[]
    contributorRoles?: ServerCreatecontributorRolesInput | string[]
    isPaused?: boolean
    pausedAt?: Date | string | null
    pausedBy?: string | null
    pauseReason?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutServerInput
    serverMembers?: ServerMemberUncheckedCreateNestedManyWithoutServerInput
  }

  export type ServerCreateOrConnectWithoutAuditLogsInput = {
    where: ServerWhereUniqueInput
    create: XOR<ServerCreateWithoutAuditLogsInput, ServerUncheckedCreateWithoutAuditLogsInput>
  }

  export type ServerUpsertWithoutAuditLogsInput = {
    update: XOR<ServerUpdateWithoutAuditLogsInput, ServerUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ServerCreateWithoutAuditLogsInput, ServerUncheckedCreateWithoutAuditLogsInput>
    where?: ServerWhereInput
  }

  export type ServerUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ServerWhereInput
    data: XOR<ServerUpdateWithoutAuditLogsInput, ServerUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ServerUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUpdateManyWithoutServerNestedInput
    serverMembers?: ServerMemberUpdateManyWithoutServerNestedInput
  }

  export type ServerUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowNoteRequests?: BoolFieldUpdateOperationsInput | boolean
    allowNoteCreation?: BoolFieldUpdateOperationsInput | boolean
    maxRequestsPerUser?: IntFieldUpdateOperationsInput | number
    requireVerification?: BoolFieldUpdateOperationsInput | boolean
    enabledChannels?: ServerUpdateenabledChannelsInput | string[]
    disabledChannels?: ServerUpdatedisabledChannelsInput | string[]
    moderatorRoles?: ServerUpdatemoderatorRolesInput | string[]
    contributorRoles?: ServerUpdatecontributorRolesInput | string[]
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutServerNestedInput
    serverMembers?: ServerMemberUncheckedUpdateManyWithoutServerNestedInput
  }

  export type NoteRequestCreateManyRequestorInput = {
    id?: string
    messageId: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
  }

  export type OpenNoteCreateManyAuthorInput = {
    id?: string
    messageId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
  }

  export type NoteRatingCreateManyRaterInput = {
    id?: string
    noteId: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
  }

  export type ServerMemberCreateManyUserInput = {
    id?: string
    serverId: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
  }

  export type NoteRequestUpdateWithoutRequestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    message?: MessageUpdateOneRequiredWithoutNoteRequestsNestedInput
  }

  export type NoteRequestUncheckedUpdateWithoutRequestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteRequestUncheckedUpdateManyWithoutRequestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpenNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    message?: MessageUpdateOneRequiredWithoutCommunityNotesNestedInput
    ratings?: NoteRatingUpdateManyWithoutNoteNestedInput
  }

  export type OpenNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    ratings?: NoteRatingUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type OpenNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    note?: OpenNoteUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type NoteRatingUncheckedUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingUncheckedUpdateManyWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type ServerMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    server?: ServerUpdateOneRequiredWithoutServerMembersNestedInput
  }

  export type ServerMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverId?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyServerInput = {
    id?: string
    discordId: string
    channelId: string
    authorId: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    timestamp: Date | string
    createdAt?: Date | string
    totalRequests?: number
    uniqueRequestors?: number
    hasActiveNote?: boolean
  }

  export type ServerMemberCreateManyServerInput = {
    id?: string
    userId: string
    roles?: ServerMemberCreaterolesInput | string[]
    joinedAt?: Date | string
  }

  export type AuditLogCreateManyServerInput = {
    id?: string
    adminId: string
    action: string
    target?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type MessageUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    noteRequests?: NoteRequestUpdateManyWithoutMessageNestedInput
    communityNotes?: OpenNoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
    noteRequests?: NoteRequestUncheckedUpdateManyWithoutMessageNestedInput
    communityNotes?: OpenNoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discordId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRequests?: IntFieldUpdateOperationsInput | number
    uniqueRequestors?: IntFieldUpdateOperationsInput | number
    hasActiveNote?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServerMemberUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServerMembershipsNestedInput
  }

  export type ServerMemberUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerMemberUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roles?: ServerMemberUpdaterolesInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteRequestCreateManyMessageInput = {
    id?: string
    requestorId: string
    reason?: string | null
    sources?: NoteRequestCreatesourcesInput | string[]
    timestamp?: Date | string
    isActive?: boolean
  }

  export type OpenNoteCreateManyMessageInput = {
    id?: string
    authorId: string
    content: string
    classification: string
    sources?: OpenNoteCreatesourcesInput | string[]
    status?: string
    submittedAt?: Date | string
    lastStatusAt?: Date | string
    helpfulCount?: number
    notHelpfulCount?: number
    totalRatings?: number
    helpfulnessRatio?: number
    isVisible?: boolean
    visibilityScore?: number
  }

  export type NoteRequestUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requestor?: UserUpdateOneRequiredWithoutNoteRequestsNestedInput
  }

  export type NoteRequestUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestorId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteRequestUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestorId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NoteRequestUpdatesourcesInput | string[]
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpenNoteUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutCommunityNotesNestedInput
    ratings?: NoteRatingUpdateManyWithoutNoteNestedInput
  }

  export type OpenNoteUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
    ratings?: NoteRatingUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type OpenNoteUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    sources?: OpenNoteUpdatesourcesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStatusAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpfulCount?: IntFieldUpdateOperationsInput | number
    notHelpfulCount?: IntFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    helpfulnessRatio?: FloatFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibilityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingCreateManyNoteInput = {
    id?: string
    raterId: string
    helpful: boolean
    reason?: string | null
    timestamp?: Date | string
    weight?: number
  }

  export type NoteRatingUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    rater?: UserUpdateOneRequiredWithoutNoteRatingsNestedInput
  }

  export type NoteRatingUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteRatingUncheckedUpdateManyWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    helpful?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServerCountOutputTypeDefaultArgs instead
     */
    export type ServerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpenNoteCountOutputTypeDefaultArgs instead
     */
    export type OpenNoteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpenNoteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServerDefaultArgs instead
     */
    export type ServerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServerMemberDefaultArgs instead
     */
    export type ServerMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServerMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteRequestDefaultArgs instead
     */
    export type NoteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpenNoteDefaultArgs instead
     */
    export type OpenNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpenNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteRatingDefaultArgs instead
     */
    export type NoteRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequestAggregationDefaultArgs instead
     */
    export type RequestAggregationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequestAggregationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateLimitingDefaultArgs instead
     */
    export type RateLimitingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateLimitingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationQueueDefaultArgs instead
     */
    export type ModerationQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationQueueDefaultArgs instead
     */
    export type NotificationQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationQueueDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}